// Code generated by proto-gen-gogo. DO NOT EDIT.
// source: github.com/vine-io/flow/api/flow.proto

package api

import (
	ebinary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
	bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

var _ = ebinary.BigEndian

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

type StepAction int32

const (
	StepAction_SA_UNKNOWN  StepAction = 0
	StepAction_SC_PREPARE  StepAction = 1
	StepAction_SC_COMMIT   StepAction = 2
	StepAction_SC_ROLLBACK StepAction = 3
	StepAction_SC_CANCEL   StepAction = 4
)

var StepAction_name = map[int32]string{
	0: "SA_UNKNOWN",
	1: "SC_PREPARE",
	2: "SC_COMMIT",
	3: "SC_ROLLBACK",
	4: "SC_CANCEL",
}

var StepAction_value = map[string]int32{
	"SA_UNKNOWN":  0,
	"SC_PREPARE":  1,
	"SC_COMMIT":   2,
	"SC_ROLLBACK": 3,
	"SC_CANCEL":   4,
}

func (x StepAction) String() string {
	return proto.EnumName(StepAction_name, int32(x))
}

func (StepAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56aef82e975cc06a, []int{0}
}

type WorkflowMode int32

const (
	WorkflowMode_WM_UNKNOWN WorkflowMode = 0
	WorkflowMode_WM_ABORT   WorkflowMode = 1
	WorkflowMode_WM_AUTO    WorkflowMode = 2
	WorkflowMode_WM_MANUAL  WorkflowMode = 3
	WorkflowMode_WM_HYBRID  WorkflowMode = 4
)

var WorkflowMode_name = map[int32]string{
	0: "WM_UNKNOWN",
	1: "WM_ABORT",
	2: "WM_AUTO",
	3: "WM_MANUAL",
	4: "WM_HYBRID",
}

var WorkflowMode_value = map[string]int32{
	"WM_UNKNOWN": 0,
	"WM_ABORT":   1,
	"WM_AUTO":    2,
	"WM_MANUAL":  3,
	"WM_HYBRID":  4,
}

func (x WorkflowMode) String() string {
	return proto.EnumName(WorkflowMode_name, int32(x))
}

func (WorkflowMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56aef82e975cc06a, []int{1}
}

type WorkflowState int32

const (
	// 位置状态
	WorkflowState_SW_UNKNOWN WorkflowState = 0
	// 暂停状态, 工作流为人工干预模式下，发生错误或进入这个状态
	WorkflowState_SW_PAUSE WorkflowState = 1
	// 工作流正在执行，处理 prepare 和 commit 状态
	WorkflowState_SW_RUNNING WorkflowState = 2
	// 工作流逻辑已经执行完成，全部步骤执行成功
	WorkflowState_SW_SUCCESS WorkflowState = 3
	// 工作流执行结束，在 cancel 阶段出现错误
	WorkflowState_SW_WARN WorkflowState = 4
	// 工作流执行结束，在 prepare 和 commit 出现错误
	WorkflowState_SW_FAILED WorkflowState = 5
)

var WorkflowState_name = map[int32]string{
	0: "SW_UNKNOWN",
	1: "SW_PAUSE",
	2: "SW_RUNNING",
	3: "SW_SUCCESS",
	4: "SW_WARN",
	5: "SW_FAILED",
}

var WorkflowState_value = map[string]int32{
	"SW_UNKNOWN": 0,
	"SW_PAUSE":   1,
	"SW_RUNNING": 2,
	"SW_SUCCESS": 3,
	"SW_WARN":    4,
	"SW_FAILED":  5,
}

func (x WorkflowState) String() string {
	return proto.EnumName(WorkflowState_name, int32(x))
}

func (WorkflowState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56aef82e975cc06a, []int{2}
}

type EventAction int32

const (
	EventAction_EA_UNKNOWN EventAction = 0
	EventAction_EA_CREATE  EventAction = 1
	EventAction_EA_UPDATE  EventAction = 2
	EventAction_EA_DELETE  EventAction = 3
)

var EventAction_name = map[int32]string{
	0: "EA_UNKNOWN",
	1: "EA_CREATE",
	2: "EA_UPDATE",
	3: "EA_DELETE",
}

var EventAction_value = map[string]int32{
	"EA_UNKNOWN": 0,
	"EA_CREATE":  1,
	"EA_UPDATE":  2,
	"EA_DELETE":  3,
}

func (x EventAction) String() string {
	return proto.EnumName(EventAction_name, int32(x))
}

func (EventAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56aef82e975cc06a, []int{3}
}

type EventType int32

const (
	EventType_ET_UNKNOWN  EventType = 0
	EventType_ET_WORKFLOW EventType = 1
	EventType_ET_STEP     EventType = 2
	EventType_ET_ENTITY   EventType = 3
	EventType_ET_ITEM     EventType = 4
	EventType_ET_RESULT   EventType = 5
)

var EventType_name = map[int32]string{
	0: "ET_UNKNOWN",
	1: "ET_WORKFLOW",
	2: "ET_STEP",
	3: "ET_ENTITY",
	4: "ET_ITEM",
	5: "ET_RESULT",
}

var EventType_value = map[string]int32{
	"ET_UNKNOWN":  0,
	"ET_WORKFLOW": 1,
	"ET_STEP":     2,
	"ET_ENTITY":   3,
	"ET_ITEM":     4,
	"ET_RESULT":   5,
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}

func (EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56aef82e975cc06a, []int{4}
}

// +gen:deepcopy
type OwnerReference struct {
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	Uid  string `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid,omitempty"`
}

func (m *OwnerReference) Reset()         { *m = OwnerReference{} }
func (m *OwnerReference) String() string { return proto.CompactTextString(m) }
func (*OwnerReference) ProtoMessage()    {}
func (*OwnerReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_56aef82e975cc06a, []int{0}
}
func (m *OwnerReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OwnerReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OwnerReference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OwnerReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OwnerReference.Merge(m, src)
}
func (m *OwnerReference) XXX_Size() int {
	return m.XSize()
}
func (m *OwnerReference) XXX_DiscardUnknown() {
	xxx_messageInfo_OwnerReference.DiscardUnknown(m)
}

var xxx_messageInfo_OwnerReference proto.InternalMessageInfo

// +gen:deepcopy
type Client struct {
	Id       string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Endpoint string `protobuf:"bytes,2,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
}

func (m *Client) Reset()         { *m = Client{} }
func (m *Client) String() string { return proto.CompactTextString(m) }
func (*Client) ProtoMessage()    {}
func (*Client) Descriptor() ([]byte, []int) {
	return fileDescriptor_56aef82e975cc06a, []int{1}
}
func (m *Client) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Client) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Client.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Client) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Client.Merge(m, src)
}
func (m *Client) XXX_Size() int {
	return m.XSize()
}
func (m *Client) XXX_DiscardUnknown() {
	xxx_messageInfo_Client.DiscardUnknown(m)
}

var xxx_messageInfo_Client proto.InternalMessageInfo

// +gen:deepcopy
type Entity struct {
	Kind            string             `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	Id              string             `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	OwnerReferences []*OwnerReference  `protobuf:"bytes,3,rep,name=ownerReferences,proto3" json:"ownerReferences,omitempty"`
	Raw             []byte             `protobuf:"bytes,4,opt,name=raw,proto3" json:"raw,omitempty"`
	Clients         map[string]*Client `protobuf:"bytes,5,rep,name=clients,proto3" json:"clients,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Entity) Reset()         { *m = Entity{} }
func (m *Entity) String() string { return proto.CompactTextString(m) }
func (*Entity) ProtoMessage()    {}
func (*Entity) Descriptor() ([]byte, []int) {
	return fileDescriptor_56aef82e975cc06a, []int{2}
}
func (m *Entity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Entity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entity.Merge(m, src)
}
func (m *Entity) XXX_Size() int {
	return m.XSize()
}
func (m *Entity) XXX_DiscardUnknown() {
	xxx_messageInfo_Entity.DiscardUnknown(m)
}

var xxx_messageInfo_Entity proto.InternalMessageInfo

// +gen:deepcopy
type Echo struct {
	Name    string             `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Entity  string             `protobuf:"bytes,2,opt,name=entity,proto3" json:"entity,omitempty"`
	Clients map[string]*Client `protobuf:"bytes,3,rep,name=clients,proto3" json:"clients,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Echo) Reset()         { *m = Echo{} }
func (m *Echo) String() string { return proto.CompactTextString(m) }
func (*Echo) ProtoMessage()    {}
func (*Echo) Descriptor() ([]byte, []int) {
	return fileDescriptor_56aef82e975cc06a, []int{3}
}
func (m *Echo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Echo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Echo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Echo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Echo.Merge(m, src)
}
func (m *Echo) XXX_Size() int {
	return m.XSize()
}
func (m *Echo) XXX_DiscardUnknown() {
	xxx_messageInfo_Echo.DiscardUnknown(m)
}

var xxx_messageInfo_Echo proto.InternalMessageInfo

// +gen:deepcopy
type Step struct {
	Name    string             `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Entity  string             `protobuf:"bytes,2,opt,name=entity,proto3" json:"entity,omitempty"`
	Clients map[string]*Client `protobuf:"bytes,3,rep,name=clients,proto3" json:"clients,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Step) Reset()         { *m = Step{} }
func (m *Step) String() string { return proto.CompactTextString(m) }
func (*Step) ProtoMessage()    {}
func (*Step) Descriptor() ([]byte, []int) {
	return fileDescriptor_56aef82e975cc06a, []int{4}
}
func (m *Step) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Step) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Step.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Step) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Step.Merge(m, src)
}
func (m *Step) XXX_Size() int {
	return m.XSize()
}
func (m *Step) XXX_DiscardUnknown() {
	xxx_messageInfo_Step.DiscardUnknown(m)
}

var xxx_messageInfo_Step proto.InternalMessageInfo

// +gen:deepcopy
type Revision struct {
	Main int64 `protobuf:"varint,1,opt,name=main,proto3" json:"main,omitempty"`
	Sub  int64 `protobuf:"varint,2,opt,name=sub,proto3" json:"sub,omitempty"`
}

func (m *Revision) Reset()         { *m = Revision{} }
func (m *Revision) String() string { return proto.CompactTextString(m) }
func (*Revision) ProtoMessage()    {}
func (*Revision) Descriptor() ([]byte, []int) {
	return fileDescriptor_56aef82e975cc06a, []int{5}
}
func (m *Revision) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Revision) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Revision.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Revision) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Revision.Merge(m, src)
}
func (m *Revision) XXX_Size() int {
	return m.XSize()
}
func (m *Revision) XXX_DiscardUnknown() {
	xxx_messageInfo_Revision.DiscardUnknown(m)
}

var xxx_messageInfo_Revision proto.InternalMessageInfo

// +gen:deepcopy
type WorkflowOption struct {
	Name       string       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Wid        string       `protobuf:"bytes,2,opt,name=wid,proto3" json:"wid,omitempty"`
	Mode       WorkflowMode `protobuf:"varint,3,opt,name=mode,proto3,enum=api.WorkflowMode" json:"mode,omitempty"`
	MaxRetries int32        `protobuf:"varint,4,opt,name=maxRetries,proto3" json:"maxRetries,omitempty"`
}

func (m *WorkflowOption) Reset()         { *m = WorkflowOption{} }
func (m *WorkflowOption) String() string { return proto.CompactTextString(m) }
func (*WorkflowOption) ProtoMessage()    {}
func (*WorkflowOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_56aef82e975cc06a, []int{6}
}
func (m *WorkflowOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowOption.Merge(m, src)
}
func (m *WorkflowOption) XXX_Size() int {
	return m.XSize()
}
func (m *WorkflowOption) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowOption.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowOption proto.InternalMessageInfo

// +gen:deepcopy
type WorkflowStatus struct {
	State    WorkflowState `protobuf:"varint,1,opt,name=state,proto3,enum=api.WorkflowState" json:"state,omitempty"`
	Msg      string        `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Action   StepAction    `protobuf:"varint,3,opt,name=action,proto3,enum=api.StepAction" json:"action,omitempty"`
	Progress string        `protobuf:"bytes,4,opt,name=progress,proto3" json:"progress,omitempty"`
	Step     string        `protobuf:"bytes,5,opt,name=step,proto3" json:"step,omitempty"`
}

func (m *WorkflowStatus) Reset()         { *m = WorkflowStatus{} }
func (m *WorkflowStatus) String() string { return proto.CompactTextString(m) }
func (*WorkflowStatus) ProtoMessage()    {}
func (*WorkflowStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_56aef82e975cc06a, []int{7}
}
func (m *WorkflowStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowStatus.Merge(m, src)
}
func (m *WorkflowStatus) XXX_Size() int {
	return m.XSize()
}
func (m *WorkflowStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowStatus proto.InternalMessageInfo

// +gen:deepcopy
type WorkflowStep struct {
	Name    string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Uid     string   `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid,omitempty"`
	Client  string   `protobuf:"bytes,3,opt,name=client,proto3" json:"client,omitempty"`
	Entity  string   `protobuf:"bytes,4,opt,name=entity,proto3" json:"entity,omitempty"`
	Injects []string `protobuf:"bytes,5,rep,name=injects,proto3" json:"injects,omitempty"`
	Logs    []string `protobuf:"bytes,6,rep,name=logs,proto3" json:"logs,omitempty"`
	Retries int32    `protobuf:"varint,7,opt,name=retries,proto3" json:"retries,omitempty"`
}

func (m *WorkflowStep) Reset()         { *m = WorkflowStep{} }
func (m *WorkflowStep) String() string { return proto.CompactTextString(m) }
func (*WorkflowStep) ProtoMessage()    {}
func (*WorkflowStep) Descriptor() ([]byte, []int) {
	return fileDescriptor_56aef82e975cc06a, []int{8}
}
func (m *WorkflowStep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowStep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowStep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowStep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowStep.Merge(m, src)
}
func (m *WorkflowStep) XXX_Size() int {
	return m.XSize()
}
func (m *WorkflowStep) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowStep.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowStep proto.InternalMessageInfo

// +gen:deepcopy
type Workflow struct {
	Option   *WorkflowOption   `protobuf:"bytes,1,opt,name=option,proto3" json:"option,omitempty"`
	Entities []*Entity         `protobuf:"bytes,2,rep,name=entities,proto3" json:"entities,omitempty"`
	Items    map[string][]byte `protobuf:"bytes,3,rep,name=items,proto3" json:"items,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Steps    []*WorkflowStep   `protobuf:"bytes,4,rep,name=steps,proto3" json:"steps,omitempty"`
	Status   *WorkflowStatus   `protobuf:"bytes,5,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *Workflow) Reset()         { *m = Workflow{} }
func (m *Workflow) String() string { return proto.CompactTextString(m) }
func (*Workflow) ProtoMessage()    {}
func (*Workflow) Descriptor() ([]byte, []int) {
	return fileDescriptor_56aef82e975cc06a, []int{9}
}
func (m *Workflow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Workflow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Workflow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Workflow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Workflow.Merge(m, src)
}
func (m *Workflow) XXX_Size() int {
	return m.XSize()
}
func (m *Workflow) XXX_DiscardUnknown() {
	xxx_messageInfo_Workflow.DiscardUnknown(m)
}

var xxx_messageInfo_Workflow proto.InternalMessageInfo

// +gen:deepcopy
type WorkflowSnapshot struct {
	Name   string        `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Wid    string        `protobuf:"bytes,2,opt,name=wid,proto3" json:"wid,omitempty"`
	Step   string        `protobuf:"bytes,3,opt,name=step,proto3" json:"step,omitempty"`
	Action StepAction    `protobuf:"varint,4,opt,name=action,proto3,enum=api.StepAction" json:"action,omitempty"`
	State  WorkflowState `protobuf:"varint,5,opt,name=state,proto3,enum=api.WorkflowState" json:"state,omitempty"`
}

func (m *WorkflowSnapshot) Reset()         { *m = WorkflowSnapshot{} }
func (m *WorkflowSnapshot) String() string { return proto.CompactTextString(m) }
func (*WorkflowSnapshot) ProtoMessage()    {}
func (*WorkflowSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_56aef82e975cc06a, []int{10}
}
func (m *WorkflowSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowSnapshot.Merge(m, src)
}
func (m *WorkflowSnapshot) XXX_Size() int {
	return m.XSize()
}
func (m *WorkflowSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowSnapshot proto.InternalMessageInfo

// +gen:deepcopy
type WorkflowWatchResult struct {
	Name   string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Wid    string      `protobuf:"bytes,2,opt,name=wid,proto3" json:"wid,omitempty"`
	Action EventAction `protobuf:"varint,3,opt,name=action,proto3,enum=api.EventAction" json:"action,omitempty"`
	Type   EventType   `protobuf:"varint,4,opt,name=type,proto3,enum=api.EventType" json:"type,omitempty"`
	Key    string      `protobuf:"bytes,5,opt,name=key,proto3" json:"key,omitempty"`
	Value  []byte      `protobuf:"bytes,6,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *WorkflowWatchResult) Reset()         { *m = WorkflowWatchResult{} }
func (m *WorkflowWatchResult) String() string { return proto.CompactTextString(m) }
func (*WorkflowWatchResult) ProtoMessage()    {}
func (*WorkflowWatchResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_56aef82e975cc06a, []int{11}
}
func (m *WorkflowWatchResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowWatchResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowWatchResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowWatchResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowWatchResult.Merge(m, src)
}
func (m *WorkflowWatchResult) XXX_Size() int {
	return m.XSize()
}
func (m *WorkflowWatchResult) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowWatchResult.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowWatchResult proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("api.StepAction", StepAction_name, StepAction_value)
	proto.RegisterEnum("api.WorkflowMode", WorkflowMode_name, WorkflowMode_value)
	proto.RegisterEnum("api.WorkflowState", WorkflowState_name, WorkflowState_value)
	proto.RegisterEnum("api.EventAction", EventAction_name, EventAction_value)
	proto.RegisterEnum("api.EventType", EventType_name, EventType_value)
	proto.RegisterType((*OwnerReference)(nil), "api.OwnerReference")
	proto.RegisterType((*Client)(nil), "api.Client")
	proto.RegisterType((*Entity)(nil), "api.Entity")
	proto.RegisterMapType((map[string]*Client)(nil), "api.Entity.ClientsEntry")
	proto.RegisterType((*Echo)(nil), "api.Echo")
	proto.RegisterMapType((map[string]*Client)(nil), "api.Echo.ClientsEntry")
	proto.RegisterType((*Step)(nil), "api.Step")
	proto.RegisterMapType((map[string]*Client)(nil), "api.Step.ClientsEntry")
	proto.RegisterType((*Revision)(nil), "api.Revision")
	proto.RegisterType((*WorkflowOption)(nil), "api.WorkflowOption")
	proto.RegisterType((*WorkflowStatus)(nil), "api.WorkflowStatus")
	proto.RegisterType((*WorkflowStep)(nil), "api.WorkflowStep")
	proto.RegisterType((*Workflow)(nil), "api.Workflow")
	proto.RegisterMapType((map[string][]byte)(nil), "api.Workflow.ItemsEntry")
	proto.RegisterType((*WorkflowSnapshot)(nil), "api.WorkflowSnapshot")
	proto.RegisterType((*WorkflowWatchResult)(nil), "api.WorkflowWatchResult")
}

func init() {
	proto.RegisterFile("github.com/vine-io/flow/api/flow.proto", fileDescriptor_56aef82e975cc06a)
}

var fileDescriptor_56aef82e975cc06a = []byte{
	// 1077 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0xcf, 0x6f, 0xe3, 0xc4,
	0x17, 0xaf, 0xed, 0x24, 0x6d, 0x5e, 0xda, 0xd4, 0x3b, 0xfb, 0xd5, 0xca, 0xea, 0x57, 0x8a, 0x4a,
	0x24, 0x68, 0x54, 0x44, 0xba, 0x14, 0x84, 0x56, 0x48, 0x1c, 0xdc, 0x74, 0x76, 0x09, 0xcd, 0x2f,
	0x8d, 0x1d, 0x59, 0x0b, 0x07, 0xcb, 0x4d, 0x66, 0xdb, 0xa1, 0x8d, 0x6d, 0xc5, 0x93, 0x96, 0x1e,
	0xf8, 0x1f, 0xf8, 0x0f, 0xe0, 0xc2, 0x0d, 0x0e, 0xfc, 0x17, 0x7b, 0xdc, 0x23, 0x47, 0x68, 0xff,
	0x0b, 0x4e, 0x68, 0x66, 0xec, 0xc4, 0xc9, 0x96, 0x65, 0x0f, 0xc0, 0xed, 0x3d, 0xbf, 0x37, 0x9f,
	0xf9, 0xbc, 0xf7, 0x3e, 0x6f, 0x64, 0x78, 0xef, 0x8c, 0xf1, 0xf3, 0xd9, 0x69, 0x73, 0x14, 0x4d,
	0x0e, 0xae, 0x58, 0x48, 0x3f, 0x60, 0xd1, 0xc1, 0x8b, 0xcb, 0xe8, 0xfa, 0x20, 0x88, 0x99, 0x34,
	0x9a, 0xf1, 0x34, 0xe2, 0x11, 0x32, 0x82, 0x98, 0xd5, 0x3f, 0x81, 0x6a, 0xff, 0x3a, 0xa4, 0x53,
	0x42, 0x5f, 0xd0, 0x29, 0x0d, 0x47, 0x14, 0x21, 0x28, 0x5c, 0xb0, 0x70, 0x6c, 0x69, 0xbb, 0x5a,
	0xa3, 0x4c, 0xa4, 0x8d, 0x4c, 0x30, 0x66, 0x6c, 0x6c, 0xe9, 0xf2, 0x93, 0x30, 0xeb, 0x1f, 0x43,
	0xa9, 0x75, 0xc9, 0x68, 0xc8, 0x51, 0x15, 0x74, 0x96, 0x65, 0xeb, 0x6c, 0x8c, 0x76, 0x60, 0x83,
	0x86, 0xe3, 0x38, 0x62, 0x21, 0x4f, 0x0f, 0xcc, 0xfd, 0xfa, 0x1f, 0x1a, 0x94, 0x70, 0xc8, 0x19,
	0xbf, 0xb9, 0xf7, 0x1a, 0x05, 0xa5, 0xcf, 0xa1, 0x3e, 0x83, 0xed, 0x68, 0x89, 0x5c, 0x62, 0x19,
	0xbb, 0x46, 0xa3, 0x72, 0xf8, 0xb0, 0x19, 0xc4, 0xac, 0xb9, 0x4c, 0x9c, 0xac, 0xe6, 0x0a, 0xd6,
	0xd3, 0xe0, 0xda, 0x2a, 0xec, 0x6a, 0x8d, 0x4d, 0x22, 0x4c, 0x74, 0x08, 0xeb, 0x23, 0xc9, 0x3a,
	0xb1, 0x8a, 0x12, 0xc8, 0x92, 0x40, 0x8a, 0x52, 0x53, 0x15, 0x94, 0xe0, 0x90, 0x4f, 0x6f, 0x48,
	0x96, 0xb8, 0xf3, 0x0c, 0x36, 0xf3, 0x01, 0x81, 0x7a, 0x41, 0x6f, 0x52, 0xde, 0xc2, 0x44, 0xef,
	0x40, 0xf1, 0x2a, 0xb8, 0x9c, 0x51, 0xc9, 0xbc, 0x72, 0x58, 0x91, 0x98, 0xea, 0x0c, 0x51, 0x91,
	0x4f, 0xf5, 0x27, 0x5a, 0xfd, 0x67, 0x0d, 0x0a, 0x78, 0x74, 0x1e, 0x89, 0xd2, 0xc3, 0x60, 0x42,
	0xb3, 0xd2, 0x85, 0x8d, 0x1e, 0x41, 0x89, 0x4a, 0x16, 0x69, 0xf9, 0xa9, 0x87, 0x1e, 0x2f, 0x18,
	0xab, 0xd2, 0x1f, 0x29, 0xc6, 0xa3, 0xf3, 0xe8, 0xbf, 0xe0, 0xeb, 0x70, 0x1a, 0xff, 0x13, 0x7c,
	0x05, 0xce, 0xbf, 0xcd, 0xf7, 0x31, 0x6c, 0x10, 0x7a, 0xc5, 0x12, 0x16, 0x85, 0x82, 0xf2, 0x24,
	0x60, 0xa1, 0x44, 0x31, 0x88, 0xb4, 0x05, 0x70, 0x32, 0x3b, 0x95, 0x20, 0x06, 0x11, 0x66, 0xfd,
	0x5b, 0xa8, 0x7a, 0xd1, 0xf4, 0x42, 0xec, 0x44, 0x3f, 0xe6, 0xe9, 0xb9, 0xd7, 0x4a, 0x35, 0xc1,
	0xb8, 0x5e, 0x88, 0xff, 0x9a, 0x8d, 0xd1, 0xbb, 0x50, 0x98, 0x44, 0x63, 0x6a, 0x19, 0xbb, 0x5a,
	0xa3, 0x7a, 0xf8, 0x40, 0xf2, 0xc9, 0x80, 0xba, 0xd1, 0x98, 0x12, 0x19, 0x46, 0x35, 0x80, 0x49,
	0xf0, 0x0d, 0xa1, 0x7c, 0xca, 0x68, 0x22, 0x65, 0x58, 0x24, 0xb9, 0x2f, 0xf5, 0x1f, 0xb5, 0xc5,
	0xfd, 0x0e, 0x0f, 0xf8, 0x2c, 0x41, 0x0d, 0x28, 0x26, 0x3c, 0xe0, 0x8a, 0x40, 0xf5, 0x10, 0x2d,
	0x41, 0x8b, 0x1c, 0x4a, 0x54, 0x82, 0x60, 0x35, 0x49, 0xce, 0x32, 0x56, 0x93, 0xe4, 0x0c, 0xed,
	0x41, 0x29, 0x18, 0x89, 0x2a, 0x52, 0x5e, 0xdb, 0xf3, 0xce, 0xdb, 0xf2, 0x33, 0x49, 0xc3, 0x62,
	0x43, 0xe3, 0x69, 0x74, 0x36, 0xa5, 0x89, 0x62, 0x55, 0x26, 0x73, 0x5f, 0x34, 0x20, 0xe1, 0x34,
	0xb6, 0x8a, 0xaa, 0x01, 0xc2, 0xae, 0xff, 0xa4, 0xc1, 0xe6, 0x82, 0xc3, 0x5f, 0x08, 0xe2, 0xb5,
	0x27, 0x42, 0x48, 0x44, 0xcd, 0x58, 0xf2, 0x29, 0x93, 0xd4, 0xcb, 0x49, 0xa7, 0xb0, 0x24, 0x1d,
	0x0b, 0xd6, 0x59, 0xf8, 0x35, 0x1d, 0xa5, 0xcb, 0x59, 0x26, 0x99, 0x2b, 0xee, 0xbb, 0x8c, 0xce,
	0x12, 0xab, 0x24, 0x3f, 0x4b, 0x5b, 0x64, 0x4f, 0xd3, 0xce, 0xae, 0xcb, 0xce, 0x66, 0x6e, 0xfd,
	0x07, 0x1d, 0x36, 0x32, 0xba, 0xe8, 0x7d, 0x28, 0x45, 0x72, 0xb4, 0x92, 0x6c, 0xf6, 0x72, 0x2c,
	0x4f, 0x9d, 0xa4, 0x29, 0x68, 0x4f, 0x3c, 0x5d, 0x9c, 0x71, 0x01, 0xaa, 0x4b, 0xf5, 0x56, 0x72,
	0xef, 0x03, 0x99, 0x07, 0x51, 0x13, 0x8a, 0x8c, 0xd3, 0x49, 0xa6, 0x71, 0x6b, 0x09, 0xb4, 0xd9,
	0x16, 0x21, 0xa5, 0x72, 0x95, 0x86, 0xf6, 0xc4, 0x58, 0x69, 0x2c, 0xda, 0x2d, 0xf2, 0x1f, 0xac,
	0x8c, 0x95, 0xc6, 0x44, 0xc5, 0x05, 0xdd, 0x44, 0x2a, 0x41, 0x0e, 0x60, 0x95, 0xae, 0x12, 0x09,
	0x49, 0x53, 0x76, 0x9e, 0x00, 0x2c, 0xae, 0xba, 0x67, 0x6f, 0xfe, 0x97, 0xdf, 0x9b, 0xcd, 0xfc,
	0xaa, 0x7c, 0xaf, 0x81, 0x39, 0x07, 0x0d, 0x83, 0x38, 0x39, 0x8f, 0xf8, 0x5b, 0x6a, 0x3f, 0x13,
	0x88, 0xb1, 0x10, 0x48, 0x4e, 0x79, 0x85, 0x37, 0x2b, 0x6f, 0x2e, 0xef, 0xe2, 0xdf, 0xc8, 0xbb,
	0xfe, 0x8b, 0x06, 0x0f, 0xb3, 0x80, 0x17, 0xf0, 0xd1, 0x39, 0xa1, 0xc9, 0xec, 0xf2, 0x6d, 0x49,
	0x36, 0x56, 0x56, 0xc1, 0x54, 0x63, 0xbc, 0xa2, 0x21, 0x5f, 0x61, 0x54, 0x87, 0x02, 0xbf, 0x89,
	0x69, 0x4a, 0xbc, 0xba, 0xc8, 0x73, 0x6f, 0x62, 0x4a, 0x64, 0x2c, 0xeb, 0x6c, 0xf1, 0x9e, 0xce,
	0x96, 0x72, 0x9d, 0xdd, 0xff, 0x0a, 0x60, 0x51, 0x33, 0xaa, 0x02, 0x38, 0xb6, 0x3f, 0xec, 0x9d,
	0xf4, 0xfa, 0x5e, 0xcf, 0x5c, 0x93, 0x7e, 0xcb, 0x1f, 0x10, 0x3c, 0xb0, 0x09, 0x36, 0x35, 0xb4,
	0x05, 0x65, 0xa7, 0xe5, 0xb7, 0xfa, 0xdd, 0x6e, 0xdb, 0x35, 0x75, 0xb4, 0x0d, 0x15, 0xa7, 0xe5,
	0x93, 0x7e, 0xa7, 0x73, 0x64, 0xb7, 0x4e, 0x4c, 0x23, 0x8b, 0xdb, 0xbd, 0x16, 0xee, 0x98, 0x85,
	0x7d, 0x6f, 0xb1, 0x83, 0xe2, 0x89, 0x11, 0x70, 0x5e, 0x37, 0x07, 0xbf, 0x09, 0x1b, 0x5e, 0xd7,
	0xb7, 0x8f, 0xfa, 0xc4, 0x35, 0x35, 0x54, 0x81, 0x75, 0xe1, 0x0d, 0xdd, 0xbe, 0xa9, 0x0b, 0x24,
	0xaf, 0xeb, 0x77, 0xed, 0xde, 0xd0, 0xee, 0x28, 0x60, 0xaf, 0xeb, 0x7f, 0xfe, 0xfc, 0x88, 0xb4,
	0x8f, 0xcd, 0xc2, 0x3e, 0x83, 0xad, 0xa5, 0x09, 0x48, 0xa2, 0xde, 0x32, 0xb2, 0xe3, 0xf9, 0x03,
	0x7b, 0xe8, 0x08, 0xda, 0x2a, 0x4a, 0x86, 0xbd, 0x5e, 0xbb, 0xf7, 0xcc, 0xd4, 0x53, 0xdf, 0x19,
	0xb6, 0x5a, 0xd8, 0x71, 0x4c, 0x43, 0xdc, 0xec, 0x78, 0xbe, 0x67, 0x93, 0x9e, 0x59, 0x90, 0x35,
	0x78, 0xfe, 0x53, 0xbb, 0xdd, 0xc1, 0xc7, 0x66, 0x71, 0xff, 0x0b, 0xa8, 0xe4, 0x66, 0x20, 0x8e,
	0xe2, 0x7c, 0x87, 0xb6, 0xa0, 0x8c, 0x6d, 0xbf, 0x45, 0xb0, 0xed, 0xa6, 0x0d, 0x12, 0xe1, 0xc1,
	0xb1, 0x70, 0xf5, 0xd4, 0x3d, 0xc6, 0x1d, 0xec, 0x62, 0xd3, 0xd8, 0x1f, 0x43, 0x79, 0x3e, 0x27,
	0x89, 0xe4, 0xe6, 0x90, 0xb6, 0xa1, 0x82, 0x5d, 0xdf, 0xeb, 0x93, 0x93, 0xa7, 0x9d, 0xbe, 0xa7,
	0xfa, 0x81, 0x5d, 0xdf, 0x71, 0xf1, 0x20, 0x45, 0x72, 0x7d, 0xdc, 0x73, 0xdb, 0xee, 0x73, 0xc5,
	0x18, 0xbb, 0x7e, 0xdb, 0xc5, 0x5d, 0xc5, 0x18, 0xbb, 0x3e, 0xc1, 0xce, 0xb0, 0xe3, 0x9a, 0xc5,
	0xa3, 0xce, 0xcb, 0xdf, 0x6b, 0x6b, 0x2f, 0x6f, 0x6b, 0xda, 0xab, 0xdb, 0x9a, 0xf6, 0xdb, 0x6d,
	0x4d, 0xfb, 0xee, 0xae, 0xb6, 0xf6, 0xea, 0xae, 0xb6, 0xf6, 0xeb, 0x5d, 0x6d, 0x0d, 0xb6, 0x59,
	0xd4, 0x14, 0x7f, 0x58, 0x4d, 0xb9, 0xf6, 0x57, 0x1f, 0x0e, 0xb4, 0x2f, 0xff, 0xff, 0x86, 0x9f,
	0xaf, 0xd3, 0x92, 0xfc, 0xf1, 0xfa, 0xe8, 0xcf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x60, 0xfc, 0x77,
	0x9e, 0xa2, 0x09, 0x00, 0x00,
}

func (m *OwnerReference) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}

func (m *Client) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}

func (m *Entity) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.OwnerReferences) > 0 {
		for _, e := range m.OwnerReferences {
			l = e.XSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	l = len(m.Raw)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Clients) > 0 {
		for k, v := range m.Clients {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.XSize()
				l += 1 + sovFlow(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovFlow(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovFlow(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Echo) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Entity)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Clients) > 0 {
		for k, v := range m.Clients {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.XSize()
				l += 1 + sovFlow(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovFlow(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovFlow(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Step) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Entity)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Clients) > 0 {
		for k, v := range m.Clients {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.XSize()
				l += 1 + sovFlow(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovFlow(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovFlow(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Revision) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Main != 0 {
		n += 1 + sovFlow(uint64(m.Main))
	}
	if m.Sub != 0 {
		n += 1 + sovFlow(uint64(m.Sub))
	}
	return n
}

func (m *WorkflowOption) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Wid)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Mode != 0 {
		n += 1 + sovFlow(uint64(m.Mode))
	}
	if m.MaxRetries != 0 {
		n += 1 + sovFlow(uint64(m.MaxRetries))
	}
	return n
}

func (m *WorkflowStatus) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovFlow(uint64(m.State))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovFlow(uint64(m.Action))
	}
	l = len(m.Progress)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Step)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}

func (m *WorkflowStep) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Client)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Entity)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Injects) > 0 {
		for _, s := range m.Injects {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.Logs) > 0 {
		for _, s := range m.Logs {
			l = len(s)
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.Retries != 0 {
		n += 1 + sovFlow(uint64(m.Retries))
	}
	return n
}

func (m *Workflow) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Option != nil {
		l = m.Option.XSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.XSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if len(m.Items) > 0 {
		for k, v := range m.Items {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovFlow(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovFlow(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovFlow(uint64(mapEntrySize))
		}
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.XSize()
			n += 1 + l + sovFlow(uint64(l))
		}
	}
	if m.Status != nil {
		l = m.Status.XSize()
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}

func (m *WorkflowSnapshot) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Wid)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Step)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovFlow(uint64(m.Action))
	}
	if m.State != 0 {
		n += 1 + sovFlow(uint64(m.State))
	}
	return n
}

func (m *WorkflowWatchResult) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Wid)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovFlow(uint64(m.Action))
	}
	if m.Type != 0 {
		n += 1 + sovFlow(uint64(m.Type))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovFlow(uint64(l))
	}
	return n
}

func sovFlow(x uint64) (n int) {
	return (bits.Len64(x|1) + 6) / 7
}
func sozFlow(x uint64) (n int) {
	return sovFlow(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *OwnerReference) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OwnerReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OwnerReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Client) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Client) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Client) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Entity) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entity) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Clients) > 0 {
		for k := range m.Clients {
			v := m.Clients[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintFlow(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFlow(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFlow(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Raw) > 0 {
		i -= len(m.Raw)
		copy(dAtA[i:], m.Raw)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Raw)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OwnerReferences) > 0 {
		for iNdEx := len(m.OwnerReferences) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OwnerReferences[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Echo) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Echo) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Echo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Clients) > 0 {
		for k := range m.Clients {
			v := m.Clients[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintFlow(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFlow(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFlow(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Entity) > 0 {
		i -= len(m.Entity)
		copy(dAtA[i:], m.Entity)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Entity)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Step) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Step) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Step) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Clients) > 0 {
		for k := range m.Clients {
			v := m.Clients[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintFlow(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFlow(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFlow(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Entity) > 0 {
		i -= len(m.Entity)
		copy(dAtA[i:], m.Entity)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Entity)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Revision) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Revision) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Revision) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sub != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Sub))
		i--
		dAtA[i] = 0x10
	}
	if m.Main != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Main))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowOption) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxRetries != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.MaxRetries))
		i--
		dAtA[i] = 0x20
	}
	if m.Mode != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Wid) > 0 {
		i -= len(m.Wid)
		copy(dAtA[i:], m.Wid)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Wid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowStatus) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Step) > 0 {
		i -= len(m.Step)
		copy(dAtA[i:], m.Step)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Step)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Progress) > 0 {
		i -= len(m.Progress)
		copy(dAtA[i:], m.Progress)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Progress)))
		i--
		dAtA[i] = 0x22
	}
	if m.Action != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x12
	}
	if m.State != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowStep) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowStep) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowStep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Retries != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Retries))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Logs) > 0 {
		for iNdEx := len(m.Logs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Logs[iNdEx])
			copy(dAtA[i:], m.Logs[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.Logs[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Injects) > 0 {
		for iNdEx := len(m.Injects) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Injects[iNdEx])
			copy(dAtA[i:], m.Injects[iNdEx])
			i = encodeVarintFlow(dAtA, i, uint64(len(m.Injects[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Entity) > 0 {
		i -= len(m.Entity)
		copy(dAtA[i:], m.Entity)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Entity)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Client) > 0 {
		i -= len(m.Client)
		copy(dAtA[i:], m.Client)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Client)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Workflow) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Workflow) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Workflow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Steps) > 0 {
		for iNdEx := len(m.Steps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Steps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Items) > 0 {
		for k := range m.Items {
			v := m.Items[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintFlow(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintFlow(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintFlow(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Entities) > 0 {
		for iNdEx := len(m.Entities) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entities[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlow(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Option != nil {
		{
			size, err := m.Option.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlow(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x28
	}
	if m.Action != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Step) > 0 {
		i -= len(m.Step)
		copy(dAtA[i:], m.Step)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Step)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Wid) > 0 {
		i -= len(m.Wid)
		copy(dAtA[i:], m.Wid)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Wid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowWatchResult) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowWatchResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowWatchResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Type != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.Action != 0 {
		i = encodeVarintFlow(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Wid) > 0 {
		i -= len(m.Wid)
		copy(dAtA[i:], m.Wid)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Wid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlow(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintFlow(dAtA []byte, offset int, v uint64) int {
	offset -= sovFlow(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *OwnerReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OwnerReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OwnerReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Client) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Client: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Client: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerReferences", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerReferences = append(m.OwnerReferences, &OwnerReference{})
			if err := m.OwnerReferences[len(m.OwnerReferences)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raw", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Raw = append(m.Raw[:0], dAtA[iNdEx:postIndex]...)
			if m.Raw == nil {
				m.Raw = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Clients == nil {
				m.Clients = make(map[string]*Client)
			}
			var mapkey string
			var mapvalue *Client
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFlow
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthFlow
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Client{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlow(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFlow
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Clients[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Echo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Echo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Echo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Clients == nil {
				m.Clients = make(map[string]*Client)
			}
			var mapkey string
			var mapvalue *Client
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFlow
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthFlow
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Client{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlow(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFlow
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Clients[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Step) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Step: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Step: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Clients == nil {
				m.Clients = make(map[string]*Client)
			}
			var mapkey string
			var mapvalue *Client
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthFlow
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthFlow
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Client{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlow(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFlow
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Clients[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Revision) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Revision: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Revision: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Main", wireType)
			}
			m.Main = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Main |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sub", wireType)
			}
			m.Sub = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sub |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= WorkflowMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRetries", wireType)
			}
			m.MaxRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRetries |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= WorkflowState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= StepAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Progress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Step = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Client", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Client = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Injects", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Injects = append(m.Injects, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logs = append(m.Logs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retries", wireType)
			}
			m.Retries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retries |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Workflow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Workflow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Workflow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Option == nil {
				m.Option = &WorkflowOption{}
			}
			if err := m.Option.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &Entity{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Items == nil {
				m.Items = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlow
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthFlow
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlow
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthFlow
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthFlow
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlow(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFlow
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Items[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &WorkflowStep{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &WorkflowStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Step = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= StepAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= WorkflowState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowWatchResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowWatchResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowWatchResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Wid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= EventAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= EventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlow
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlow
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlow(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlow
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlow(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlow
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlow
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFlow
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFlow
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFlow
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFlow        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlow          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFlow = fmt.Errorf("proto: unexpected end of group")
)

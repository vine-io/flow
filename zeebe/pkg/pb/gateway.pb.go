// Code generated by proto-gen-gogo. DO NOT EDIT.
// source: zeebe/pkg/pb/gateway.proto

package pb

import (
	context "context"
	ebinary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

var _ = ebinary.BigEndian

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Describes the Raft role of the broker for a given partition
type Partition_PartitionBrokerRole int32

const (
	Partition_LEADER   Partition_PartitionBrokerRole = 0
	Partition_FOLLOWER Partition_PartitionBrokerRole = 1
	Partition_INACTIVE Partition_PartitionBrokerRole = 2
)

var Partition_PartitionBrokerRole_name = map[int32]string{
	0: "LEADER",
	1: "FOLLOWER",
	2: "INACTIVE",
}

var Partition_PartitionBrokerRole_value = map[string]int32{
	"LEADER":   0,
	"FOLLOWER": 1,
	"INACTIVE": 2,
}

func (x Partition_PartitionBrokerRole) String() string {
	return proto.EnumName(Partition_PartitionBrokerRole_name, int32(x))
}

func (Partition_PartitionBrokerRole) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{39, 0}
}

// Describes the current health of the partition
type Partition_PartitionBrokerHealth int32

const (
	Partition_HEALTHY   Partition_PartitionBrokerHealth = 0
	Partition_UNHEALTHY Partition_PartitionBrokerHealth = 1
	Partition_DEAD      Partition_PartitionBrokerHealth = 2
)

var Partition_PartitionBrokerHealth_name = map[int32]string{
	0: "HEALTHY",
	1: "UNHEALTHY",
	2: "DEAD",
}

var Partition_PartitionBrokerHealth_value = map[string]int32{
	"HEALTHY":   0,
	"UNHEALTHY": 1,
	"DEAD":      2,
}

func (x Partition_PartitionBrokerHealth) String() string {
	return proto.EnumName(Partition_PartitionBrokerHealth_name, int32(x))
}

func (Partition_PartitionBrokerHealth) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{39, 1}
}

type ActivateJobsRequest struct {
	// the job type, as defined in the BPMN process (e.g. <zeebe:taskDefinition
	// type="payment-service" />)
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// the name of the worker activating the jobs, mostly used for logging purposes
	Worker string `protobuf:"bytes,2,opt,name=worker,proto3" json:"worker,omitempty"`
	// a job returned after this call will not be activated by another call until the
	// timeout (in ms) has been reached
	Timeout int64 `protobuf:"varint,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// the maximum jobs to activate by this request
	MaxJobsToActivate int32 `protobuf:"varint,4,opt,name=maxJobsToActivate,proto3" json:"maxJobsToActivate,omitempty"`
	// a list of variables to fetch as the job variables; if empty, all visible variables at
	// the time of activation for the scope of the job will be returned
	FetchVariable []string `protobuf:"bytes,5,rep,name=fetchVariable,proto3" json:"fetchVariable,omitempty"`
	// The request will be completed when at least one job is activated or after the requestTimeout (in ms).
	// if the requestTimeout = 0, a default timeout is used.
	// if the requestTimeout < 0, long polling is disabled and the request is completed immediately, even when no job is activated.
	RequestTimeout int64 `protobuf:"varint,6,opt,name=requestTimeout,proto3" json:"requestTimeout,omitempty"`
}

func (m *ActivateJobsRequest) Reset()         { *m = ActivateJobsRequest{} }
func (m *ActivateJobsRequest) String() string { return proto.CompactTextString(m) }
func (*ActivateJobsRequest) ProtoMessage()    {}
func (*ActivateJobsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{0}
}
func (m *ActivateJobsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivateJobsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivateJobsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivateJobsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivateJobsRequest.Merge(m, src)
}
func (m *ActivateJobsRequest) XXX_Size() int {
	return m.XSize()
}
func (m *ActivateJobsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivateJobsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ActivateJobsRequest proto.InternalMessageInfo

type ActivateJobsResponse struct {
	// list of activated jobs
	Jobs []*ActivatedJob `protobuf:"bytes,1,rep,name=jobs,proto3" json:"jobs,omitempty"`
}

func (m *ActivateJobsResponse) Reset()         { *m = ActivateJobsResponse{} }
func (m *ActivateJobsResponse) String() string { return proto.CompactTextString(m) }
func (*ActivateJobsResponse) ProtoMessage()    {}
func (*ActivateJobsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{1}
}
func (m *ActivateJobsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivateJobsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivateJobsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivateJobsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivateJobsResponse.Merge(m, src)
}
func (m *ActivateJobsResponse) XXX_Size() int {
	return m.XSize()
}
func (m *ActivateJobsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivateJobsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ActivateJobsResponse proto.InternalMessageInfo

type ActivatedJob struct {
	// the key, a unique identifier for the job
	Key int64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	// the type of the job (should match what was requested)
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// the job's process instance key
	ProcessInstanceKey int64 `protobuf:"varint,3,opt,name=processInstanceKey,proto3" json:"processInstanceKey,omitempty"`
	// the bpmn process ID of the job process definition
	BpmnProcessId string `protobuf:"bytes,4,opt,name=bpmnProcessId,proto3" json:"bpmnProcessId,omitempty"`
	// the version of the job process definition
	ProcessDefinitionVersion int32 `protobuf:"varint,5,opt,name=processDefinitionVersion,proto3" json:"processDefinitionVersion,omitempty"`
	// the key of the job process definition
	ProcessDefinitionKey int64 `protobuf:"varint,6,opt,name=processDefinitionKey,proto3" json:"processDefinitionKey,omitempty"`
	// the associated task element ID
	ElementId string `protobuf:"bytes,7,opt,name=elementId,proto3" json:"elementId,omitempty"`
	// the unique key identifying the associated task, unique within the scope of the
	// process instance
	ElementInstanceKey int64 `protobuf:"varint,8,opt,name=elementInstanceKey,proto3" json:"elementInstanceKey,omitempty"`
	// a set of custom headers defined during modelling; returned as a serialized
	// JSON document
	CustomHeaders string `protobuf:"bytes,9,opt,name=customHeaders,proto3" json:"customHeaders,omitempty"`
	// the name of the worker which activated this job
	Worker string `protobuf:"bytes,10,opt,name=worker,proto3" json:"worker,omitempty"`
	// the amount of retries left to this job (should always be positive)
	Retries int32 `protobuf:"varint,11,opt,name=retries,proto3" json:"retries,omitempty"`
	// when the job can be activated again, sent as a UNIX epoch timestamp
	Deadline int64 `protobuf:"varint,12,opt,name=deadline,proto3" json:"deadline,omitempty"`
	// JSON document, computed at activation time, consisting of all visible variables to
	// the task scope
	Variables string `protobuf:"bytes,13,opt,name=variables,proto3" json:"variables,omitempty"`
}

func (m *ActivatedJob) Reset()         { *m = ActivatedJob{} }
func (m *ActivatedJob) String() string { return proto.CompactTextString(m) }
func (*ActivatedJob) ProtoMessage()    {}
func (*ActivatedJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{2}
}
func (m *ActivatedJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivatedJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivatedJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivatedJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivatedJob.Merge(m, src)
}
func (m *ActivatedJob) XXX_Size() int {
	return m.XSize()
}
func (m *ActivatedJob) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivatedJob.DiscardUnknown(m)
}

var xxx_messageInfo_ActivatedJob proto.InternalMessageInfo

type CancelProcessInstanceRequest struct {
	// the process instance key (as, for example, obtained from
	// CreateProcessInstanceResponse)
	ProcessInstanceKey int64 `protobuf:"varint,1,opt,name=processInstanceKey,proto3" json:"processInstanceKey,omitempty"`
}

func (m *CancelProcessInstanceRequest) Reset()         { *m = CancelProcessInstanceRequest{} }
func (m *CancelProcessInstanceRequest) String() string { return proto.CompactTextString(m) }
func (*CancelProcessInstanceRequest) ProtoMessage()    {}
func (*CancelProcessInstanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{3}
}
func (m *CancelProcessInstanceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelProcessInstanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelProcessInstanceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelProcessInstanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelProcessInstanceRequest.Merge(m, src)
}
func (m *CancelProcessInstanceRequest) XXX_Size() int {
	return m.XSize()
}
func (m *CancelProcessInstanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelProcessInstanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CancelProcessInstanceRequest proto.InternalMessageInfo

type CancelProcessInstanceResponse struct {
}

func (m *CancelProcessInstanceResponse) Reset()         { *m = CancelProcessInstanceResponse{} }
func (m *CancelProcessInstanceResponse) String() string { return proto.CompactTextString(m) }
func (*CancelProcessInstanceResponse) ProtoMessage()    {}
func (*CancelProcessInstanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{4}
}
func (m *CancelProcessInstanceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelProcessInstanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelProcessInstanceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelProcessInstanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelProcessInstanceResponse.Merge(m, src)
}
func (m *CancelProcessInstanceResponse) XXX_Size() int {
	return m.XSize()
}
func (m *CancelProcessInstanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelProcessInstanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CancelProcessInstanceResponse proto.InternalMessageInfo

type CompleteJobRequest struct {
	// the unique job identifier, as obtained from ActivateJobsResponse
	JobKey int64 `protobuf:"varint,1,opt,name=jobKey,proto3" json:"jobKey,omitempty"`
	// a JSON document representing the variables in the current task scope
	Variables string `protobuf:"bytes,2,opt,name=variables,proto3" json:"variables,omitempty"`
}

func (m *CompleteJobRequest) Reset()         { *m = CompleteJobRequest{} }
func (m *CompleteJobRequest) String() string { return proto.CompactTextString(m) }
func (*CompleteJobRequest) ProtoMessage()    {}
func (*CompleteJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{5}
}
func (m *CompleteJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompleteJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompleteJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompleteJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompleteJobRequest.Merge(m, src)
}
func (m *CompleteJobRequest) XXX_Size() int {
	return m.XSize()
}
func (m *CompleteJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CompleteJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CompleteJobRequest proto.InternalMessageInfo

type CompleteJobResponse struct {
}

func (m *CompleteJobResponse) Reset()         { *m = CompleteJobResponse{} }
func (m *CompleteJobResponse) String() string { return proto.CompactTextString(m) }
func (*CompleteJobResponse) ProtoMessage()    {}
func (*CompleteJobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{6}
}
func (m *CompleteJobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompleteJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompleteJobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompleteJobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompleteJobResponse.Merge(m, src)
}
func (m *CompleteJobResponse) XXX_Size() int {
	return m.XSize()
}
func (m *CompleteJobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CompleteJobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CompleteJobResponse proto.InternalMessageInfo

type CreateProcessInstanceRequest struct {
	// the unique key identifying the process definition (e.g. returned from a process
	// in the DeployProcessResponse message)
	ProcessDefinitionKey int64 `protobuf:"varint,1,opt,name=processDefinitionKey,proto3" json:"processDefinitionKey,omitempty"`
	// the BPMN process ID of the process definition
	BpmnProcessId string `protobuf:"bytes,2,opt,name=bpmnProcessId,proto3" json:"bpmnProcessId,omitempty"`
	// the version of the process; set to -1 to use the latest version
	Version int32 `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	// JSON document that will instantiate the variables for the root variable scope of the
	// process instance; it must be a JSON object, as variables will be mapped in a
	// key-value fashion. e.g. { "a": 1, "b": 2 } will create two variables, named "a" and
	// "b" respectively, with their associated values. [{ "a": 1, "b": 2 }] would not be a
	// valid argument, as the root of the JSON document is an array and not an object.
	Variables string `protobuf:"bytes,4,opt,name=variables,proto3" json:"variables,omitempty"`
	// List of start instructions. If empty (default) the process instance
	// will start at the start event. If non-empty the process instance will apply start
	// instructions after it has been created
	StartInstructions []*ProcessInstanceCreationStartInstruction `protobuf:"bytes,5,rep,name=startInstructions,proto3" json:"startInstructions,omitempty"`
}

func (m *CreateProcessInstanceRequest) Reset()         { *m = CreateProcessInstanceRequest{} }
func (m *CreateProcessInstanceRequest) String() string { return proto.CompactTextString(m) }
func (*CreateProcessInstanceRequest) ProtoMessage()    {}
func (*CreateProcessInstanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{7}
}
func (m *CreateProcessInstanceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateProcessInstanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateProcessInstanceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateProcessInstanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateProcessInstanceRequest.Merge(m, src)
}
func (m *CreateProcessInstanceRequest) XXX_Size() int {
	return m.XSize()
}
func (m *CreateProcessInstanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateProcessInstanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateProcessInstanceRequest proto.InternalMessageInfo

type ProcessInstanceCreationStartInstruction struct {
	// element ID
	ElementId string `protobuf:"bytes,1,opt,name=elementId,proto3" json:"elementId,omitempty"`
}

func (m *ProcessInstanceCreationStartInstruction) Reset() {
	*m = ProcessInstanceCreationStartInstruction{}
}
func (m *ProcessInstanceCreationStartInstruction) String() string { return proto.CompactTextString(m) }
func (*ProcessInstanceCreationStartInstruction) ProtoMessage()    {}
func (*ProcessInstanceCreationStartInstruction) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{8}
}
func (m *ProcessInstanceCreationStartInstruction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessInstanceCreationStartInstruction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessInstanceCreationStartInstruction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessInstanceCreationStartInstruction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessInstanceCreationStartInstruction.Merge(m, src)
}
func (m *ProcessInstanceCreationStartInstruction) XXX_Size() int {
	return m.XSize()
}
func (m *ProcessInstanceCreationStartInstruction) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessInstanceCreationStartInstruction.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessInstanceCreationStartInstruction proto.InternalMessageInfo

type CreateProcessInstanceResponse struct {
	// the key of the process definition which was used to create the process instance
	ProcessDefinitionKey int64 `protobuf:"varint,1,opt,name=processDefinitionKey,proto3" json:"processDefinitionKey,omitempty"`
	// the BPMN process ID of the process definition which was used to create the process
	// instance
	BpmnProcessId string `protobuf:"bytes,2,opt,name=bpmnProcessId,proto3" json:"bpmnProcessId,omitempty"`
	// the version of the process definition which was used to create the process instance
	Version int32 `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	// the unique identifier of the created process instance; to be used wherever a request
	// needs a process instance key (e.g. CancelProcessInstanceRequest)
	ProcessInstanceKey int64 `protobuf:"varint,4,opt,name=processInstanceKey,proto3" json:"processInstanceKey,omitempty"`
}

func (m *CreateProcessInstanceResponse) Reset()         { *m = CreateProcessInstanceResponse{} }
func (m *CreateProcessInstanceResponse) String() string { return proto.CompactTextString(m) }
func (*CreateProcessInstanceResponse) ProtoMessage()    {}
func (*CreateProcessInstanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{9}
}
func (m *CreateProcessInstanceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateProcessInstanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateProcessInstanceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateProcessInstanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateProcessInstanceResponse.Merge(m, src)
}
func (m *CreateProcessInstanceResponse) XXX_Size() int {
	return m.XSize()
}
func (m *CreateProcessInstanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateProcessInstanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateProcessInstanceResponse proto.InternalMessageInfo

type CreateProcessInstanceWithResultRequest struct {
	Request *CreateProcessInstanceRequest `protobuf:"bytes,1,opt,name=request,proto3" json:"request,omitempty"`
	// timeout (in ms). the request will be closed if the process is not completed
	// before the requestTimeout.
	// if requestTimeout = 0, uses the generic requestTimeout configured in the gateway.
	RequestTimeout int64 `protobuf:"varint,2,opt,name=requestTimeout,proto3" json:"requestTimeout,omitempty"`
	// list of names of variables to be included in `CreateProcessInstanceWithResultResponse.variables`
	// if empty, all visible variables in the root scope will be returned.
	FetchVariables []string `protobuf:"bytes,3,rep,name=fetchVariables,proto3" json:"fetchVariables,omitempty"`
}

func (m *CreateProcessInstanceWithResultRequest) Reset() {
	*m = CreateProcessInstanceWithResultRequest{}
}
func (m *CreateProcessInstanceWithResultRequest) String() string { return proto.CompactTextString(m) }
func (*CreateProcessInstanceWithResultRequest) ProtoMessage()    {}
func (*CreateProcessInstanceWithResultRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{10}
}
func (m *CreateProcessInstanceWithResultRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateProcessInstanceWithResultRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateProcessInstanceWithResultRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateProcessInstanceWithResultRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateProcessInstanceWithResultRequest.Merge(m, src)
}
func (m *CreateProcessInstanceWithResultRequest) XXX_Size() int {
	return m.XSize()
}
func (m *CreateProcessInstanceWithResultRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateProcessInstanceWithResultRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateProcessInstanceWithResultRequest proto.InternalMessageInfo

type CreateProcessInstanceWithResultResponse struct {
	// the key of the process definition which was used to create the process instance
	ProcessDefinitionKey int64 `protobuf:"varint,1,opt,name=processDefinitionKey,proto3" json:"processDefinitionKey,omitempty"`
	// the BPMN process ID of the process definition which was used to create the process
	// instance
	BpmnProcessId string `protobuf:"bytes,2,opt,name=bpmnProcessId,proto3" json:"bpmnProcessId,omitempty"`
	// the version of the process definition which was used to create the process instance
	Version int32 `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	// the unique identifier of the created process instance; to be used wherever a request
	// needs a process instance key (e.g. CancelProcessInstanceRequest)
	ProcessInstanceKey int64 `protobuf:"varint,4,opt,name=processInstanceKey,proto3" json:"processInstanceKey,omitempty"`
	// JSON document
	// consists of visible variables in the root scope
	Variables string `protobuf:"bytes,5,opt,name=variables,proto3" json:"variables,omitempty"`
}

func (m *CreateProcessInstanceWithResultResponse) Reset() {
	*m = CreateProcessInstanceWithResultResponse{}
}
func (m *CreateProcessInstanceWithResultResponse) String() string { return proto.CompactTextString(m) }
func (*CreateProcessInstanceWithResultResponse) ProtoMessage()    {}
func (*CreateProcessInstanceWithResultResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{11}
}
func (m *CreateProcessInstanceWithResultResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateProcessInstanceWithResultResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateProcessInstanceWithResultResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateProcessInstanceWithResultResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateProcessInstanceWithResultResponse.Merge(m, src)
}
func (m *CreateProcessInstanceWithResultResponse) XXX_Size() int {
	return m.XSize()
}
func (m *CreateProcessInstanceWithResultResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateProcessInstanceWithResultResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateProcessInstanceWithResultResponse proto.InternalMessageInfo

type EvaluateDecisionRequest struct {
	// the unique key identifying the decision to be evaluated (e.g. returned
	// from a decision in the DeployResourceResponse message)
	DecisionKey int64 `protobuf:"varint,1,opt,name=decisionKey,proto3" json:"decisionKey,omitempty"`
	// the ID of the decision to be evaluated
	DecisionId string `protobuf:"bytes,2,opt,name=decisionId,proto3" json:"decisionId,omitempty"`
	// JSON document that will instantiate the variables for the decision to be
	// evaluated; it must be a JSON object, as variables will be mapped in a
	// key-value fashion, e.g. { "a": 1, "b": 2 } will create two variables,
	// named "a" and "b" respectively, with their associated values.
	// [{ "a": 1, "b": 2 }] would not be a valid argument, as the root of the
	// JSON document is an array and not an object.
	Variables string `protobuf:"bytes,3,opt,name=variables,proto3" json:"variables,omitempty"`
}

func (m *EvaluateDecisionRequest) Reset()         { *m = EvaluateDecisionRequest{} }
func (m *EvaluateDecisionRequest) String() string { return proto.CompactTextString(m) }
func (*EvaluateDecisionRequest) ProtoMessage()    {}
func (*EvaluateDecisionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{12}
}
func (m *EvaluateDecisionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvaluateDecisionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvaluateDecisionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvaluateDecisionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvaluateDecisionRequest.Merge(m, src)
}
func (m *EvaluateDecisionRequest) XXX_Size() int {
	return m.XSize()
}
func (m *EvaluateDecisionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EvaluateDecisionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EvaluateDecisionRequest proto.InternalMessageInfo

type EvaluateDecisionResponse struct {
	// the unique key identifying the decision which was evaluated (e.g. returned
	// from a decision in the DeployResourceResponse message)
	DecisionKey int64 `protobuf:"varint,1,opt,name=decisionKey,proto3" json:"decisionKey,omitempty"`
	// the ID of the decision which was evaluated
	DecisionId string `protobuf:"bytes,2,opt,name=decisionId,proto3" json:"decisionId,omitempty"`
	// the name of the decision which was evaluated
	DecisionName string `protobuf:"bytes,3,opt,name=decisionName,proto3" json:"decisionName,omitempty"`
	// the version of the decision which was evaluated
	DecisionVersion int32 `protobuf:"varint,4,opt,name=decisionVersion,proto3" json:"decisionVersion,omitempty"`
	// the ID of the decision requirements graph that the decision which was
	// evaluated is part of.
	DecisionRequirementsId string `protobuf:"bytes,5,opt,name=decisionRequirementsId,proto3" json:"decisionRequirementsId,omitempty"`
	// the unique key identifying the decision requirements graph that the
	// decision which was evaluated is part of.
	DecisionRequirementsKey int64 `protobuf:"varint,6,opt,name=decisionRequirementsKey,proto3" json:"decisionRequirementsKey,omitempty"`
	// JSON document that will instantiate the result of the decision which was
	// evaluated; it will be a JSON object, as the result output will be mapped
	// in a key-value fashion, e.g. { "a": 1 }.
	DecisionOutput string `protobuf:"bytes,7,opt,name=decisionOutput,proto3" json:"decisionOutput,omitempty"`
	// a list of decisions that were evaluated within the requested decision evaluation
	EvaluatedDecisions []*EvaluatedDecision `protobuf:"bytes,8,rep,name=evaluatedDecisions,proto3" json:"evaluatedDecisions,omitempty"`
	// an optional string indicating the ID of the decision which
	// failed during evaluation
	FailedDecisionId string `protobuf:"bytes,9,opt,name=failedDecisionId,proto3" json:"failedDecisionId,omitempty"`
	// an optional message describing why the decision which was evaluated failed
	FailureMessage string `protobuf:"bytes,10,opt,name=failureMessage,proto3" json:"failureMessage,omitempty"`
}

func (m *EvaluateDecisionResponse) Reset()         { *m = EvaluateDecisionResponse{} }
func (m *EvaluateDecisionResponse) String() string { return proto.CompactTextString(m) }
func (*EvaluateDecisionResponse) ProtoMessage()    {}
func (*EvaluateDecisionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{13}
}
func (m *EvaluateDecisionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvaluateDecisionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvaluateDecisionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvaluateDecisionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvaluateDecisionResponse.Merge(m, src)
}
func (m *EvaluateDecisionResponse) XXX_Size() int {
	return m.XSize()
}
func (m *EvaluateDecisionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EvaluateDecisionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EvaluateDecisionResponse proto.InternalMessageInfo

type EvaluatedDecision struct {
	// the unique key identifying the decision which was evaluated (e.g. returned
	// from a decision in the DeployResourceResponse message)
	DecisionKey int64 `protobuf:"varint,1,opt,name=decisionKey,proto3" json:"decisionKey,omitempty"`
	// the ID of the decision which was evaluated
	DecisionId string `protobuf:"bytes,2,opt,name=decisionId,proto3" json:"decisionId,omitempty"`
	// the name of the decision which was evaluated
	DecisionName string `protobuf:"bytes,3,opt,name=decisionName,proto3" json:"decisionName,omitempty"`
	// the version of the decision which was evaluated
	DecisionVersion int32 `protobuf:"varint,4,opt,name=decisionVersion,proto3" json:"decisionVersion,omitempty"`
	// the type of the decision which was evaluated
	DecisionType string `protobuf:"bytes,5,opt,name=decisionType,proto3" json:"decisionType,omitempty"`
	// JSON document that will instantiate the result of the decision which was
	// evaluated; it will be a JSON object, as the result output will be mapped
	// in a key-value fashion, e.g. { "a": 1 }.
	DecisionOutput string `protobuf:"bytes,6,opt,name=decisionOutput,proto3" json:"decisionOutput,omitempty"`
	// the decision rules that matched within this decision evaluation
	MatchedRules []*MatchedDecisionRule `protobuf:"bytes,7,rep,name=matchedRules,proto3" json:"matchedRules,omitempty"`
	// the decision inputs that were evaluated within this decision evaluation
	EvaluatedInputs []*EvaluatedDecisionInput `protobuf:"bytes,8,rep,name=evaluatedInputs,proto3" json:"evaluatedInputs,omitempty"`
}

func (m *EvaluatedDecision) Reset()         { *m = EvaluatedDecision{} }
func (m *EvaluatedDecision) String() string { return proto.CompactTextString(m) }
func (*EvaluatedDecision) ProtoMessage()    {}
func (*EvaluatedDecision) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{14}
}
func (m *EvaluatedDecision) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvaluatedDecision) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvaluatedDecision.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvaluatedDecision) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvaluatedDecision.Merge(m, src)
}
func (m *EvaluatedDecision) XXX_Size() int {
	return m.XSize()
}
func (m *EvaluatedDecision) XXX_DiscardUnknown() {
	xxx_messageInfo_EvaluatedDecision.DiscardUnknown(m)
}

var xxx_messageInfo_EvaluatedDecision proto.InternalMessageInfo

type EvaluatedDecisionInput struct {
	// the id of the evaluated decision input
	InputId string `protobuf:"bytes,1,opt,name=inputId,proto3" json:"inputId,omitempty"`
	// the name of the evaluated decision input
	InputName string `protobuf:"bytes,2,opt,name=inputName,proto3" json:"inputName,omitempty"`
	// the value of the evaluated decision input
	InputValue string `protobuf:"bytes,3,opt,name=inputValue,proto3" json:"inputValue,omitempty"`
}

func (m *EvaluatedDecisionInput) Reset()         { *m = EvaluatedDecisionInput{} }
func (m *EvaluatedDecisionInput) String() string { return proto.CompactTextString(m) }
func (*EvaluatedDecisionInput) ProtoMessage()    {}
func (*EvaluatedDecisionInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{15}
}
func (m *EvaluatedDecisionInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvaluatedDecisionInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvaluatedDecisionInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvaluatedDecisionInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvaluatedDecisionInput.Merge(m, src)
}
func (m *EvaluatedDecisionInput) XXX_Size() int {
	return m.XSize()
}
func (m *EvaluatedDecisionInput) XXX_DiscardUnknown() {
	xxx_messageInfo_EvaluatedDecisionInput.DiscardUnknown(m)
}

var xxx_messageInfo_EvaluatedDecisionInput proto.InternalMessageInfo

type EvaluatedDecisionOutput struct {
	// the id of the evaluated decision output
	OutputId string `protobuf:"bytes,1,opt,name=outputId,proto3" json:"outputId,omitempty"`
	// the name of the evaluated decision output
	OutputName string `protobuf:"bytes,2,opt,name=outputName,proto3" json:"outputName,omitempty"`
	// the value of the evaluated decision output
	OutputValue string `protobuf:"bytes,3,opt,name=outputValue,proto3" json:"outputValue,omitempty"`
}

func (m *EvaluatedDecisionOutput) Reset()         { *m = EvaluatedDecisionOutput{} }
func (m *EvaluatedDecisionOutput) String() string { return proto.CompactTextString(m) }
func (*EvaluatedDecisionOutput) ProtoMessage()    {}
func (*EvaluatedDecisionOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{16}
}
func (m *EvaluatedDecisionOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvaluatedDecisionOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvaluatedDecisionOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvaluatedDecisionOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvaluatedDecisionOutput.Merge(m, src)
}
func (m *EvaluatedDecisionOutput) XXX_Size() int {
	return m.XSize()
}
func (m *EvaluatedDecisionOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_EvaluatedDecisionOutput.DiscardUnknown(m)
}

var xxx_messageInfo_EvaluatedDecisionOutput proto.InternalMessageInfo

type MatchedDecisionRule struct {
	// the id of the matched rule
	RuleId string `protobuf:"bytes,1,opt,name=ruleId,proto3" json:"ruleId,omitempty"`
	// the index of the matched rule
	RuleIndex int32 `protobuf:"varint,2,opt,name=ruleIndex,proto3" json:"ruleIndex,omitempty"`
	// the evaluated decision outputs
	EvaluatedOutputs []*EvaluatedDecisionOutput `protobuf:"bytes,3,rep,name=evaluatedOutputs,proto3" json:"evaluatedOutputs,omitempty"`
}

func (m *MatchedDecisionRule) Reset()         { *m = MatchedDecisionRule{} }
func (m *MatchedDecisionRule) String() string { return proto.CompactTextString(m) }
func (*MatchedDecisionRule) ProtoMessage()    {}
func (*MatchedDecisionRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{17}
}
func (m *MatchedDecisionRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MatchedDecisionRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MatchedDecisionRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MatchedDecisionRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchedDecisionRule.Merge(m, src)
}
func (m *MatchedDecisionRule) XXX_Size() int {
	return m.XSize()
}
func (m *MatchedDecisionRule) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchedDecisionRule.DiscardUnknown(m)
}

var xxx_messageInfo_MatchedDecisionRule proto.InternalMessageInfo

// Deprecated: Do not use.
type DeployProcessRequest struct {
	// List of process resources to deploy
	Processes []*ProcessRequestObject `protobuf:"bytes,1,rep,name=processes,proto3" json:"processes,omitempty"`
}

func (m *DeployProcessRequest) Reset()         { *m = DeployProcessRequest{} }
func (m *DeployProcessRequest) String() string { return proto.CompactTextString(m) }
func (*DeployProcessRequest) ProtoMessage()    {}
func (*DeployProcessRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{18}
}
func (m *DeployProcessRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeployProcessRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeployProcessRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeployProcessRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeployProcessRequest.Merge(m, src)
}
func (m *DeployProcessRequest) XXX_Size() int {
	return m.XSize()
}
func (m *DeployProcessRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeployProcessRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeployProcessRequest proto.InternalMessageInfo

// Deprecated: Do not use.
type ProcessRequestObject struct {
	// the resource basename, e.g. myProcess.bpmn
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// the process definition as a UTF8-encoded string
	Definition []byte `protobuf:"bytes,2,opt,name=definition,proto3" json:"definition,omitempty"`
}

func (m *ProcessRequestObject) Reset()         { *m = ProcessRequestObject{} }
func (m *ProcessRequestObject) String() string { return proto.CompactTextString(m) }
func (*ProcessRequestObject) ProtoMessage()    {}
func (*ProcessRequestObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{19}
}
func (m *ProcessRequestObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessRequestObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessRequestObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessRequestObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessRequestObject.Merge(m, src)
}
func (m *ProcessRequestObject) XXX_Size() int {
	return m.XSize()
}
func (m *ProcessRequestObject) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessRequestObject.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessRequestObject proto.InternalMessageInfo

// Deprecated: Do not use.
type DeployProcessResponse struct {
	// the unique key identifying the deployment
	Key int64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	// a list of deployed processes
	Processes []*ProcessMetadata `protobuf:"bytes,2,rep,name=processes,proto3" json:"processes,omitempty"`
}

func (m *DeployProcessResponse) Reset()         { *m = DeployProcessResponse{} }
func (m *DeployProcessResponse) String() string { return proto.CompactTextString(m) }
func (*DeployProcessResponse) ProtoMessage()    {}
func (*DeployProcessResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{20}
}
func (m *DeployProcessResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeployProcessResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeployProcessResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeployProcessResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeployProcessResponse.Merge(m, src)
}
func (m *DeployProcessResponse) XXX_Size() int {
	return m.XSize()
}
func (m *DeployProcessResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeployProcessResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeployProcessResponse proto.InternalMessageInfo

type DeployResourceRequest struct {
	// list of resources to deploy
	Resources []*Resource `protobuf:"bytes,1,rep,name=resources,proto3" json:"resources,omitempty"`
}

func (m *DeployResourceRequest) Reset()         { *m = DeployResourceRequest{} }
func (m *DeployResourceRequest) String() string { return proto.CompactTextString(m) }
func (*DeployResourceRequest) ProtoMessage()    {}
func (*DeployResourceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{21}
}
func (m *DeployResourceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeployResourceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeployResourceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeployResourceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeployResourceRequest.Merge(m, src)
}
func (m *DeployResourceRequest) XXX_Size() int {
	return m.XSize()
}
func (m *DeployResourceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeployResourceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeployResourceRequest proto.InternalMessageInfo

type Resource struct {
	// the resource name, e.g. myProcess.bpmn or myDecision.dmn
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// the file content as a UTF8-encoded string
	Content []byte `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *Resource) Reset()         { *m = Resource{} }
func (m *Resource) String() string { return proto.CompactTextString(m) }
func (*Resource) ProtoMessage()    {}
func (*Resource) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{22}
}
func (m *Resource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Resource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Resource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Resource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resource.Merge(m, src)
}
func (m *Resource) XXX_Size() int {
	return m.XSize()
}
func (m *Resource) XXX_DiscardUnknown() {
	xxx_messageInfo_Resource.DiscardUnknown(m)
}

var xxx_messageInfo_Resource proto.InternalMessageInfo

type DeployResourceResponse struct {
	// the unique key identifying the deployment
	Key int64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	// a list of deployed resources, e.g. processes
	Deployments []*Deployment `protobuf:"bytes,2,rep,name=deployments,proto3" json:"deployments,omitempty"`
}

func (m *DeployResourceResponse) Reset()         { *m = DeployResourceResponse{} }
func (m *DeployResourceResponse) String() string { return proto.CompactTextString(m) }
func (*DeployResourceResponse) ProtoMessage()    {}
func (*DeployResourceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{23}
}
func (m *DeployResourceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeployResourceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeployResourceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeployResourceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeployResourceResponse.Merge(m, src)
}
func (m *DeployResourceResponse) XXX_Size() int {
	return m.XSize()
}
func (m *DeployResourceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeployResourceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeployResourceResponse proto.InternalMessageInfo

type Deployment struct {
	// each deployment has only one metadata
	//
	// Types that are valid to be assigned to Metadata:
	//
	//	*Deployment_Process
	//	*Deployment_Decision
	//	*Deployment_DecisionRequirements
	Metadata isDeployment_Metadata `protobuf_oneof:"Metadata"`
}

func (m *Deployment) Reset()         { *m = Deployment{} }
func (m *Deployment) String() string { return proto.CompactTextString(m) }
func (*Deployment) ProtoMessage()    {}
func (*Deployment) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{24}
}
func (m *Deployment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deployment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deployment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deployment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deployment.Merge(m, src)
}
func (m *Deployment) XXX_Size() int {
	return m.XSize()
}
func (m *Deployment) XXX_DiscardUnknown() {
	xxx_messageInfo_Deployment.DiscardUnknown(m)
}

var xxx_messageInfo_Deployment proto.InternalMessageInfo

type isDeployment_Metadata interface {
	isDeployment_Metadata()
	MarshalTo([]byte) (int, error)
	XSize() int
}

type Deployment_Process struct {
	Process *ProcessMetadata `protobuf:"bytes,1,opt,name=process,proto3,oneof" json:"process,omitempty"`
}
type Deployment_Decision struct {
	Decision *DecisionMetadata `protobuf:"bytes,2,opt,name=decision,proto3,oneof" json:"decision,omitempty"`
}
type Deployment_DecisionRequirements struct {
	DecisionRequirements *DecisionRequirementsMetadata `protobuf:"bytes,3,opt,name=decisionRequirements,proto3,oneof" json:"decisionRequirements,omitempty"`
}

func (*Deployment_Process) isDeployment_Metadata()              {}
func (*Deployment_Decision) isDeployment_Metadata()             {}
func (*Deployment_DecisionRequirements) isDeployment_Metadata() {}

func (m *Deployment) GetMetadata() isDeployment_Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Deployment) GetProcess() *ProcessMetadata {
	if x, ok := m.GetMetadata().(*Deployment_Process); ok {
		return x.Process
	}
	return nil
}

func (m *Deployment) GetDecision() *DecisionMetadata {
	if x, ok := m.GetMetadata().(*Deployment_Decision); ok {
		return x.Decision
	}
	return nil
}

func (m *Deployment) GetDecisionRequirements() *DecisionRequirementsMetadata {
	if x, ok := m.GetMetadata().(*Deployment_DecisionRequirements); ok {
		return x.DecisionRequirements
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Deployment) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Deployment_Process)(nil),
		(*Deployment_Decision)(nil),
		(*Deployment_DecisionRequirements)(nil),
	}
}

type ProcessMetadata struct {
	// the bpmn process ID, as parsed during deployment; together with the version forms a
	// unique identifier for a specific process definition
	BpmnProcessId string `protobuf:"bytes,1,opt,name=bpmnProcessId,proto3" json:"bpmnProcessId,omitempty"`
	// the assigned process version
	Version int32 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	// the assigned key, which acts as a unique identifier for this process
	ProcessDefinitionKey int64 `protobuf:"varint,3,opt,name=processDefinitionKey,proto3" json:"processDefinitionKey,omitempty"`
	// the resource name (see: ProcessRequestObject.name) from which this process was
	// parsed
	ResourceName string `protobuf:"bytes,4,opt,name=resourceName,proto3" json:"resourceName,omitempty"`
}

func (m *ProcessMetadata) Reset()         { *m = ProcessMetadata{} }
func (m *ProcessMetadata) String() string { return proto.CompactTextString(m) }
func (*ProcessMetadata) ProtoMessage()    {}
func (*ProcessMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{25}
}
func (m *ProcessMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessMetadata.Merge(m, src)
}
func (m *ProcessMetadata) XXX_Size() int {
	return m.XSize()
}
func (m *ProcessMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessMetadata proto.InternalMessageInfo

type DecisionMetadata struct {
	// the dmn decision ID, as parsed during deployment; together with the
	// versions forms a unique identifier for a specific decision
	DmnDecisionId string `protobuf:"bytes,1,opt,name=dmnDecisionId,proto3" json:"dmnDecisionId,omitempty"`
	// the dmn name of the decision, as parsed during deployment
	DmnDecisionName string `protobuf:"bytes,2,opt,name=dmnDecisionName,proto3" json:"dmnDecisionName,omitempty"`
	// the assigned decision version
	Version int32 `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	// the assigned decision key, which acts as a unique identifier for this
	// decision
	DecisionKey int64 `protobuf:"varint,4,opt,name=decisionKey,proto3" json:"decisionKey,omitempty"`
	// the dmn ID of the decision requirements graph that this decision is part
	// of, as parsed during deployment
	DmnDecisionRequirementsId string `protobuf:"bytes,5,opt,name=dmnDecisionRequirementsId,proto3" json:"dmnDecisionRequirementsId,omitempty"`
	// the assigned key of the decision requirements graph that this decision is
	// part of
	DecisionRequirementsKey int64 `protobuf:"varint,6,opt,name=decisionRequirementsKey,proto3" json:"decisionRequirementsKey,omitempty"`
}

func (m *DecisionMetadata) Reset()         { *m = DecisionMetadata{} }
func (m *DecisionMetadata) String() string { return proto.CompactTextString(m) }
func (*DecisionMetadata) ProtoMessage()    {}
func (*DecisionMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{26}
}
func (m *DecisionMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecisionMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecisionMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecisionMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecisionMetadata.Merge(m, src)
}
func (m *DecisionMetadata) XXX_Size() int {
	return m.XSize()
}
func (m *DecisionMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_DecisionMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_DecisionMetadata proto.InternalMessageInfo

type DecisionRequirementsMetadata struct {
	// the dmn decision requirements ID, as parsed during deployment; together
	// with the versions forms a unique identifier for a specific decision
	DmnDecisionRequirementsId string `protobuf:"bytes,1,opt,name=dmnDecisionRequirementsId,proto3" json:"dmnDecisionRequirementsId,omitempty"`
	// the dmn name of the decision requirements, as parsed during deployment
	DmnDecisionRequirementsName string `protobuf:"bytes,2,opt,name=dmnDecisionRequirementsName,proto3" json:"dmnDecisionRequirementsName,omitempty"`
	// the assigned decision requirements version
	Version int32 `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	// the assigned decision requirements key, which acts as a unique identifier
	// for this decision requirements
	DecisionRequirementsKey int64 `protobuf:"varint,4,opt,name=decisionRequirementsKey,proto3" json:"decisionRequirementsKey,omitempty"`
	// the resource name (see: Resource.name) from which this decision
	// requirements was parsed
	ResourceName string `protobuf:"bytes,5,opt,name=resourceName,proto3" json:"resourceName,omitempty"`
}

func (m *DecisionRequirementsMetadata) Reset()         { *m = DecisionRequirementsMetadata{} }
func (m *DecisionRequirementsMetadata) String() string { return proto.CompactTextString(m) }
func (*DecisionRequirementsMetadata) ProtoMessage()    {}
func (*DecisionRequirementsMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{27}
}
func (m *DecisionRequirementsMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecisionRequirementsMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecisionRequirementsMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecisionRequirementsMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecisionRequirementsMetadata.Merge(m, src)
}
func (m *DecisionRequirementsMetadata) XXX_Size() int {
	return m.XSize()
}
func (m *DecisionRequirementsMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_DecisionRequirementsMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_DecisionRequirementsMetadata proto.InternalMessageInfo

type FailJobRequest struct {
	// the unique job identifier, as obtained when activating the job
	JobKey int64 `protobuf:"varint,1,opt,name=jobKey,proto3" json:"jobKey,omitempty"`
	// the amount of retries the job should have left
	Retries int32 `protobuf:"varint,2,opt,name=retries,proto3" json:"retries,omitempty"`
	// an optional message describing why the job failed
	// this is particularly useful if a job runs out of retries and an incident is raised,
	// as it this message can help explain why an incident was raised
	ErrorMessage string `protobuf:"bytes,3,opt,name=errorMessage,proto3" json:"errorMessage,omitempty"`
	// the backoff timeout (in ms) for the next retry
	RetryBackOff int64 `protobuf:"varint,4,opt,name=retryBackOff,proto3" json:"retryBackOff,omitempty"`
	// JSON document that will instantiate the variables at the local scope of the
	// job's associated task; it must be a JSON object, as variables will be mapped in a
	// key-value fashion. e.g. { "a": 1, "b": 2 } will create two variables, named "a" and
	// "b" respectively, with their associated values. [{ "a": 1, "b": 2 }] would not be a
	// valid argument, as the root of the JSON document is an array and not an object.
	Variables string `protobuf:"bytes,5,opt,name=variables,proto3" json:"variables,omitempty"`
}

func (m *FailJobRequest) Reset()         { *m = FailJobRequest{} }
func (m *FailJobRequest) String() string { return proto.CompactTextString(m) }
func (*FailJobRequest) ProtoMessage()    {}
func (*FailJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{28}
}
func (m *FailJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FailJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FailJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FailJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FailJobRequest.Merge(m, src)
}
func (m *FailJobRequest) XXX_Size() int {
	return m.XSize()
}
func (m *FailJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FailJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FailJobRequest proto.InternalMessageInfo

type FailJobResponse struct {
}

func (m *FailJobResponse) Reset()         { *m = FailJobResponse{} }
func (m *FailJobResponse) String() string { return proto.CompactTextString(m) }
func (*FailJobResponse) ProtoMessage()    {}
func (*FailJobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{29}
}
func (m *FailJobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FailJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FailJobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FailJobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FailJobResponse.Merge(m, src)
}
func (m *FailJobResponse) XXX_Size() int {
	return m.XSize()
}
func (m *FailJobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FailJobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FailJobResponse proto.InternalMessageInfo

type ThrowErrorRequest struct {
	// the unique job identifier, as obtained when activating the job
	JobKey int64 `protobuf:"varint,1,opt,name=jobKey,proto3" json:"jobKey,omitempty"`
	// the error code that will be matched with an error catch event
	ErrorCode string `protobuf:"bytes,2,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
	// an optional error message that provides additional context
	ErrorMessage string `protobuf:"bytes,3,opt,name=errorMessage,proto3" json:"errorMessage,omitempty"`
	// JSON document that will instantiate the variables at the local scope of the
	// error catch event that catches the thrown error; it must be a JSON object, as variables will be mapped in a
	// key-value fashion. e.g. { "a": 1, "b": 2 } will create two variables, named "a" and
	// "b" respectively, with their associated values. [{ "a": 1, "b": 2 }] would not be a
	// valid argument, as the root of the JSON document is an array and not an object.
	Variables string `protobuf:"bytes,4,opt,name=variables,proto3" json:"variables,omitempty"`
}

func (m *ThrowErrorRequest) Reset()         { *m = ThrowErrorRequest{} }
func (m *ThrowErrorRequest) String() string { return proto.CompactTextString(m) }
func (*ThrowErrorRequest) ProtoMessage()    {}
func (*ThrowErrorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{30}
}
func (m *ThrowErrorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThrowErrorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThrowErrorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThrowErrorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThrowErrorRequest.Merge(m, src)
}
func (m *ThrowErrorRequest) XXX_Size() int {
	return m.XSize()
}
func (m *ThrowErrorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ThrowErrorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ThrowErrorRequest proto.InternalMessageInfo

type ThrowErrorResponse struct {
}

func (m *ThrowErrorResponse) Reset()         { *m = ThrowErrorResponse{} }
func (m *ThrowErrorResponse) String() string { return proto.CompactTextString(m) }
func (*ThrowErrorResponse) ProtoMessage()    {}
func (*ThrowErrorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{31}
}
func (m *ThrowErrorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThrowErrorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThrowErrorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThrowErrorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThrowErrorResponse.Merge(m, src)
}
func (m *ThrowErrorResponse) XXX_Size() int {
	return m.XSize()
}
func (m *ThrowErrorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ThrowErrorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ThrowErrorResponse proto.InternalMessageInfo

type PublishMessageRequest struct {
	// the name of the message
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// the correlation key of the message
	CorrelationKey string `protobuf:"bytes,2,opt,name=correlationKey,proto3" json:"correlationKey,omitempty"`
	// how long the message should be buffered on the broker, in milliseconds
	TimeToLive int64 `protobuf:"varint,3,opt,name=timeToLive,proto3" json:"timeToLive,omitempty"`
	// the unique ID of the message; can be omitted. only useful to ensure only one message
	// with the given ID will ever be published (during its lifetime)
	MessageId string `protobuf:"bytes,4,opt,name=messageId,proto3" json:"messageId,omitempty"`
	// the message variables as a JSON document; to be valid, the root of the document must be an
	// object, e.g. { "a": "foo" }. [ "foo" ] would not be valid.
	Variables string `protobuf:"bytes,5,opt,name=variables,proto3" json:"variables,omitempty"`
}

func (m *PublishMessageRequest) Reset()         { *m = PublishMessageRequest{} }
func (m *PublishMessageRequest) String() string { return proto.CompactTextString(m) }
func (*PublishMessageRequest) ProtoMessage()    {}
func (*PublishMessageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{32}
}
func (m *PublishMessageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublishMessageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublishMessageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublishMessageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishMessageRequest.Merge(m, src)
}
func (m *PublishMessageRequest) XXX_Size() int {
	return m.XSize()
}
func (m *PublishMessageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishMessageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PublishMessageRequest proto.InternalMessageInfo

type PublishMessageResponse struct {
	// the unique ID of the message that was published
	Key int64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *PublishMessageResponse) Reset()         { *m = PublishMessageResponse{} }
func (m *PublishMessageResponse) String() string { return proto.CompactTextString(m) }
func (*PublishMessageResponse) ProtoMessage()    {}
func (*PublishMessageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{33}
}
func (m *PublishMessageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublishMessageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublishMessageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublishMessageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishMessageResponse.Merge(m, src)
}
func (m *PublishMessageResponse) XXX_Size() int {
	return m.XSize()
}
func (m *PublishMessageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishMessageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PublishMessageResponse proto.InternalMessageInfo

type ResolveIncidentRequest struct {
	// the unique ID of the incident to resolve
	IncidentKey int64 `protobuf:"varint,1,opt,name=incidentKey,proto3" json:"incidentKey,omitempty"`
}

func (m *ResolveIncidentRequest) Reset()         { *m = ResolveIncidentRequest{} }
func (m *ResolveIncidentRequest) String() string { return proto.CompactTextString(m) }
func (*ResolveIncidentRequest) ProtoMessage()    {}
func (*ResolveIncidentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{34}
}
func (m *ResolveIncidentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolveIncidentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResolveIncidentRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResolveIncidentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolveIncidentRequest.Merge(m, src)
}
func (m *ResolveIncidentRequest) XXX_Size() int {
	return m.XSize()
}
func (m *ResolveIncidentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolveIncidentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResolveIncidentRequest proto.InternalMessageInfo

type ResolveIncidentResponse struct {
}

func (m *ResolveIncidentResponse) Reset()         { *m = ResolveIncidentResponse{} }
func (m *ResolveIncidentResponse) String() string { return proto.CompactTextString(m) }
func (*ResolveIncidentResponse) ProtoMessage()    {}
func (*ResolveIncidentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{35}
}
func (m *ResolveIncidentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResolveIncidentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResolveIncidentResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResolveIncidentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResolveIncidentResponse.Merge(m, src)
}
func (m *ResolveIncidentResponse) XXX_Size() int {
	return m.XSize()
}
func (m *ResolveIncidentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ResolveIncidentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ResolveIncidentResponse proto.InternalMessageInfo

type TopologyRequest struct {
}

func (m *TopologyRequest) Reset()         { *m = TopologyRequest{} }
func (m *TopologyRequest) String() string { return proto.CompactTextString(m) }
func (*TopologyRequest) ProtoMessage()    {}
func (*TopologyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{36}
}
func (m *TopologyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopologyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopologyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopologyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopologyRequest.Merge(m, src)
}
func (m *TopologyRequest) XXX_Size() int {
	return m.XSize()
}
func (m *TopologyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TopologyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TopologyRequest proto.InternalMessageInfo

type TopologyResponse struct {
	// list of brokers part of this cluster
	Brokers []*BrokerInfo `protobuf:"bytes,1,rep,name=brokers,proto3" json:"brokers,omitempty"`
	// how many nodes are in the cluster
	ClusterSize int32 `protobuf:"varint,2,opt,name=clusterSize,proto3" json:"clusterSize,omitempty"`
	// how many partitions are spread across the cluster
	PartitionsCount int32 `protobuf:"varint,3,opt,name=partitionsCount,proto3" json:"partitionsCount,omitempty"`
	// configured replication factor for this cluster
	ReplicationFactor int32 `protobuf:"varint,4,opt,name=replicationFactor,proto3" json:"replicationFactor,omitempty"`
	// gateway version
	GatewayVersion string `protobuf:"bytes,5,opt,name=gatewayVersion,proto3" json:"gatewayVersion,omitempty"`
}

func (m *TopologyResponse) Reset()         { *m = TopologyResponse{} }
func (m *TopologyResponse) String() string { return proto.CompactTextString(m) }
func (*TopologyResponse) ProtoMessage()    {}
func (*TopologyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{37}
}
func (m *TopologyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopologyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopologyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopologyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopologyResponse.Merge(m, src)
}
func (m *TopologyResponse) XXX_Size() int {
	return m.XSize()
}
func (m *TopologyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TopologyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TopologyResponse proto.InternalMessageInfo

type BrokerInfo struct {
	// unique (within a cluster) node ID for the broker
	NodeId int32 `protobuf:"varint,1,opt,name=nodeId,proto3" json:"nodeId,omitempty"`
	// hostname of the broker
	Host string `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty"`
	// port for the broker
	Port int32 `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	// list of partitions managed or replicated on this broker
	Partitions []*Partition `protobuf:"bytes,4,rep,name=partitions,proto3" json:"partitions,omitempty"`
	// broker version
	Version string `protobuf:"bytes,5,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *BrokerInfo) Reset()         { *m = BrokerInfo{} }
func (m *BrokerInfo) String() string { return proto.CompactTextString(m) }
func (*BrokerInfo) ProtoMessage()    {}
func (*BrokerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{38}
}
func (m *BrokerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BrokerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BrokerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BrokerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BrokerInfo.Merge(m, src)
}
func (m *BrokerInfo) XXX_Size() int {
	return m.XSize()
}
func (m *BrokerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BrokerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BrokerInfo proto.InternalMessageInfo

type Partition struct {
	// the unique ID of this partition
	PartitionId int32 `protobuf:"varint,1,opt,name=partitionId,proto3" json:"partitionId,omitempty"`
	// the role of the broker for this partition
	Role Partition_PartitionBrokerRole `protobuf:"varint,2,opt,name=role,proto3,enum=gateway_protocol.Partition_PartitionBrokerRole" json:"role,omitempty"`
	// the health of this partition
	Health Partition_PartitionBrokerHealth `protobuf:"varint,3,opt,name=health,proto3,enum=gateway_protocol.Partition_PartitionBrokerHealth" json:"health,omitempty"`
}

func (m *Partition) Reset()         { *m = Partition{} }
func (m *Partition) String() string { return proto.CompactTextString(m) }
func (*Partition) ProtoMessage()    {}
func (*Partition) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{39}
}
func (m *Partition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Partition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Partition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Partition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Partition.Merge(m, src)
}
func (m *Partition) XXX_Size() int {
	return m.XSize()
}
func (m *Partition) XXX_DiscardUnknown() {
	xxx_messageInfo_Partition.DiscardUnknown(m)
}

var xxx_messageInfo_Partition proto.InternalMessageInfo

type UpdateJobRetriesRequest struct {
	// the unique job identifier, as obtained through ActivateJobs
	JobKey int64 `protobuf:"varint,1,opt,name=jobKey,proto3" json:"jobKey,omitempty"`
	// the new amount of retries for the job; must be positive
	Retries int32 `protobuf:"varint,2,opt,name=retries,proto3" json:"retries,omitempty"`
}

func (m *UpdateJobRetriesRequest) Reset()         { *m = UpdateJobRetriesRequest{} }
func (m *UpdateJobRetriesRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateJobRetriesRequest) ProtoMessage()    {}
func (*UpdateJobRetriesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{40}
}
func (m *UpdateJobRetriesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateJobRetriesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateJobRetriesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateJobRetriesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateJobRetriesRequest.Merge(m, src)
}
func (m *UpdateJobRetriesRequest) XXX_Size() int {
	return m.XSize()
}
func (m *UpdateJobRetriesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateJobRetriesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateJobRetriesRequest proto.InternalMessageInfo

type UpdateJobRetriesResponse struct {
}

func (m *UpdateJobRetriesResponse) Reset()         { *m = UpdateJobRetriesResponse{} }
func (m *UpdateJobRetriesResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateJobRetriesResponse) ProtoMessage()    {}
func (*UpdateJobRetriesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{41}
}
func (m *UpdateJobRetriesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateJobRetriesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateJobRetriesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateJobRetriesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateJobRetriesResponse.Merge(m, src)
}
func (m *UpdateJobRetriesResponse) XXX_Size() int {
	return m.XSize()
}
func (m *UpdateJobRetriesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateJobRetriesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateJobRetriesResponse proto.InternalMessageInfo

type SetVariablesRequest struct {
	// the unique identifier of a particular element; can be the process instance key (as
	// obtained during instance creation), or a given element, such as a service task (see
	// elementInstanceKey on the job message)
	ElementInstanceKey int64 `protobuf:"varint,1,opt,name=elementInstanceKey,proto3" json:"elementInstanceKey,omitempty"`
	// a JSON serialized document describing variables as key value pairs; the root of the document
	// must be an object
	Variables string `protobuf:"bytes,2,opt,name=variables,proto3" json:"variables,omitempty"`
	// if true, the variables will be merged strictly into the local scope (as indicated by
	// elementInstanceKey); this means the variables is not propagated to upper scopes.
	// for example, let's say we have two scopes, '1' and '2', with each having effective variables as:
	// 1 => `{ "foo" : 2 }`, and 2 => `{ "bar" : 1 }`. if we send an update request with
	// elementInstanceKey = 2, variables `{ "foo" : 5 }`, and local is true, then scope 1 will
	// be unchanged, and scope 2 will now be `{ "bar" : 1, "foo" 5 }`. if local was false, however,
	// then scope 1 would be `{ "foo": 5 }`, and scope 2 would be `{ "bar" : 1 }`.
	Local bool `protobuf:"varint,3,opt,name=local,proto3" json:"local,omitempty"`
}

func (m *SetVariablesRequest) Reset()         { *m = SetVariablesRequest{} }
func (m *SetVariablesRequest) String() string { return proto.CompactTextString(m) }
func (*SetVariablesRequest) ProtoMessage()    {}
func (*SetVariablesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{42}
}
func (m *SetVariablesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetVariablesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetVariablesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetVariablesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetVariablesRequest.Merge(m, src)
}
func (m *SetVariablesRequest) XXX_Size() int {
	return m.XSize()
}
func (m *SetVariablesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetVariablesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetVariablesRequest proto.InternalMessageInfo

type SetVariablesResponse struct {
	// the unique key of the set variables command
	Key int64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *SetVariablesResponse) Reset()         { *m = SetVariablesResponse{} }
func (m *SetVariablesResponse) String() string { return proto.CompactTextString(m) }
func (*SetVariablesResponse) ProtoMessage()    {}
func (*SetVariablesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{43}
}
func (m *SetVariablesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetVariablesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetVariablesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetVariablesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetVariablesResponse.Merge(m, src)
}
func (m *SetVariablesResponse) XXX_Size() int {
	return m.XSize()
}
func (m *SetVariablesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetVariablesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetVariablesResponse proto.InternalMessageInfo

type ModifyProcessInstanceRequest struct {
	// the key of the process instance that should be modified
	ProcessInstanceKey int64 `protobuf:"varint,1,opt,name=processInstanceKey,proto3" json:"processInstanceKey,omitempty"`
	// instructions describing which elements should be activated in which scopes,
	// and which variables should be created
	ActivateInstructions []*ModifyProcessInstanceRequest_ActivateInstruction `protobuf:"bytes,2,rep,name=activateInstructions,proto3" json:"activateInstructions,omitempty"`
	// instructions describing which elements should be terminated
	TerminateInstructions []*ModifyProcessInstanceRequest_TerminateInstruction `protobuf:"bytes,3,rep,name=terminateInstructions,proto3" json:"terminateInstructions,omitempty"`
}

func (m *ModifyProcessInstanceRequest) Reset()         { *m = ModifyProcessInstanceRequest{} }
func (m *ModifyProcessInstanceRequest) String() string { return proto.CompactTextString(m) }
func (*ModifyProcessInstanceRequest) ProtoMessage()    {}
func (*ModifyProcessInstanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{44}
}
func (m *ModifyProcessInstanceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModifyProcessInstanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModifyProcessInstanceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModifyProcessInstanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifyProcessInstanceRequest.Merge(m, src)
}
func (m *ModifyProcessInstanceRequest) XXX_Size() int {
	return m.XSize()
}
func (m *ModifyProcessInstanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifyProcessInstanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ModifyProcessInstanceRequest proto.InternalMessageInfo

type ModifyProcessInstanceRequest_ActivateInstruction struct {
	// the id of the element that should be activated
	ElementId string `protobuf:"bytes,1,opt,name=elementId,proto3" json:"elementId,omitempty"`
	// the key of the ancestor scope the element instance should be created in;
	// set to -1 to create the new element instance within an existing element
	// instance of the flow scope
	AncestorElementInstanceKey int64 `protobuf:"varint,2,opt,name=ancestorElementInstanceKey,proto3" json:"ancestorElementInstanceKey,omitempty"`
	// instructions describing which variables should be created
	VariableInstructions []*ModifyProcessInstanceRequest_VariableInstruction `protobuf:"bytes,3,rep,name=variableInstructions,proto3" json:"variableInstructions,omitempty"`
}

func (m *ModifyProcessInstanceRequest_ActivateInstruction) Reset() {
	*m = ModifyProcessInstanceRequest_ActivateInstruction{}
}
func (m *ModifyProcessInstanceRequest_ActivateInstruction) String() string {
	return proto.CompactTextString(m)
}
func (*ModifyProcessInstanceRequest_ActivateInstruction) ProtoMessage() {}
func (*ModifyProcessInstanceRequest_ActivateInstruction) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{44, 0}
}
func (m *ModifyProcessInstanceRequest_ActivateInstruction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModifyProcessInstanceRequest_ActivateInstruction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModifyProcessInstanceRequest_ActivateInstruction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModifyProcessInstanceRequest_ActivateInstruction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifyProcessInstanceRequest_ActivateInstruction.Merge(m, src)
}
func (m *ModifyProcessInstanceRequest_ActivateInstruction) XXX_Size() int {
	return m.XSize()
}
func (m *ModifyProcessInstanceRequest_ActivateInstruction) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifyProcessInstanceRequest_ActivateInstruction.DiscardUnknown(m)
}

var xxx_messageInfo_ModifyProcessInstanceRequest_ActivateInstruction proto.InternalMessageInfo

type ModifyProcessInstanceRequest_VariableInstruction struct {
	// JSON document that will instantiate the variables for the root variable scope of the
	// process instance; it must be a JSON object, as variables will be mapped in a
	// key-value fashion. e.g. { "a": 1, "b": 2 } will create two variables, named "a" and
	// "b" respectively, with their associated values. [{ "a": 1, "b": 2 }] would not be a
	// valid argument, as the root of the JSON document is an array and not an object.
	Variables string `protobuf:"bytes,1,opt,name=variables,proto3" json:"variables,omitempty"`
	// the id of the element in which scope the variables should be created;
	// leave empty to create the variables in the global scope of the process instance
	ScopeId string `protobuf:"bytes,2,opt,name=scopeId,proto3" json:"scopeId,omitempty"`
}

func (m *ModifyProcessInstanceRequest_VariableInstruction) Reset() {
	*m = ModifyProcessInstanceRequest_VariableInstruction{}
}
func (m *ModifyProcessInstanceRequest_VariableInstruction) String() string {
	return proto.CompactTextString(m)
}
func (*ModifyProcessInstanceRequest_VariableInstruction) ProtoMessage() {}
func (*ModifyProcessInstanceRequest_VariableInstruction) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{44, 1}
}
func (m *ModifyProcessInstanceRequest_VariableInstruction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModifyProcessInstanceRequest_VariableInstruction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModifyProcessInstanceRequest_VariableInstruction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModifyProcessInstanceRequest_VariableInstruction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifyProcessInstanceRequest_VariableInstruction.Merge(m, src)
}
func (m *ModifyProcessInstanceRequest_VariableInstruction) XXX_Size() int {
	return m.XSize()
}
func (m *ModifyProcessInstanceRequest_VariableInstruction) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifyProcessInstanceRequest_VariableInstruction.DiscardUnknown(m)
}

var xxx_messageInfo_ModifyProcessInstanceRequest_VariableInstruction proto.InternalMessageInfo

type ModifyProcessInstanceRequest_TerminateInstruction struct {
	// the id of the element that should be terminated
	ElementInstanceKey int64 `protobuf:"varint,1,opt,name=elementInstanceKey,proto3" json:"elementInstanceKey,omitempty"`
}

func (m *ModifyProcessInstanceRequest_TerminateInstruction) Reset() {
	*m = ModifyProcessInstanceRequest_TerminateInstruction{}
}
func (m *ModifyProcessInstanceRequest_TerminateInstruction) String() string {
	return proto.CompactTextString(m)
}
func (*ModifyProcessInstanceRequest_TerminateInstruction) ProtoMessage() {}
func (*ModifyProcessInstanceRequest_TerminateInstruction) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{44, 2}
}
func (m *ModifyProcessInstanceRequest_TerminateInstruction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModifyProcessInstanceRequest_TerminateInstruction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModifyProcessInstanceRequest_TerminateInstruction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModifyProcessInstanceRequest_TerminateInstruction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifyProcessInstanceRequest_TerminateInstruction.Merge(m, src)
}
func (m *ModifyProcessInstanceRequest_TerminateInstruction) XXX_Size() int {
	return m.XSize()
}
func (m *ModifyProcessInstanceRequest_TerminateInstruction) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifyProcessInstanceRequest_TerminateInstruction.DiscardUnknown(m)
}

var xxx_messageInfo_ModifyProcessInstanceRequest_TerminateInstruction proto.InternalMessageInfo

type ModifyProcessInstanceResponse struct {
}

func (m *ModifyProcessInstanceResponse) Reset()         { *m = ModifyProcessInstanceResponse{} }
func (m *ModifyProcessInstanceResponse) String() string { return proto.CompactTextString(m) }
func (*ModifyProcessInstanceResponse) ProtoMessage()    {}
func (*ModifyProcessInstanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{45}
}
func (m *ModifyProcessInstanceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModifyProcessInstanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModifyProcessInstanceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModifyProcessInstanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifyProcessInstanceResponse.Merge(m, src)
}
func (m *ModifyProcessInstanceResponse) XXX_Size() int {
	return m.XSize()
}
func (m *ModifyProcessInstanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifyProcessInstanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ModifyProcessInstanceResponse proto.InternalMessageInfo

type DeleteResourceRequest struct {
	// The key of the resource that should be deleted. This can either be the key
	// of a process definition, or the key of a decision requirements definition.
	ResourceKey int64 `protobuf:"varint,1,opt,name=resourceKey,proto3" json:"resourceKey,omitempty"`
}

func (m *DeleteResourceRequest) Reset()         { *m = DeleteResourceRequest{} }
func (m *DeleteResourceRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteResourceRequest) ProtoMessage()    {}
func (*DeleteResourceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{46}
}
func (m *DeleteResourceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteResourceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteResourceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteResourceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteResourceRequest.Merge(m, src)
}
func (m *DeleteResourceRequest) XXX_Size() int {
	return m.XSize()
}
func (m *DeleteResourceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteResourceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteResourceRequest proto.InternalMessageInfo

type DeleteResourceResponse struct {
}

func (m *DeleteResourceResponse) Reset()         { *m = DeleteResourceResponse{} }
func (m *DeleteResourceResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteResourceResponse) ProtoMessage()    {}
func (*DeleteResourceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{47}
}
func (m *DeleteResourceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteResourceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteResourceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteResourceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteResourceResponse.Merge(m, src)
}
func (m *DeleteResourceResponse) XXX_Size() int {
	return m.XSize()
}
func (m *DeleteResourceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteResourceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteResourceResponse proto.InternalMessageInfo

type BroadcastSignalRequest struct {
	// The name of the signal
	SignalName string `protobuf:"bytes,1,opt,name=signalName,proto3" json:"signalName,omitempty"`
	// the signal variables as a JSON document; to be valid, the root of the document must be an
	// object, e.g. { "a": "foo" }. [ "foo" ] would not be valid.
	Variables string `protobuf:"bytes,2,opt,name=variables,proto3" json:"variables,omitempty"`
}

func (m *BroadcastSignalRequest) Reset()         { *m = BroadcastSignalRequest{} }
func (m *BroadcastSignalRequest) String() string { return proto.CompactTextString(m) }
func (*BroadcastSignalRequest) ProtoMessage()    {}
func (*BroadcastSignalRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{48}
}
func (m *BroadcastSignalRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BroadcastSignalRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BroadcastSignalRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BroadcastSignalRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BroadcastSignalRequest.Merge(m, src)
}
func (m *BroadcastSignalRequest) XXX_Size() int {
	return m.XSize()
}
func (m *BroadcastSignalRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BroadcastSignalRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BroadcastSignalRequest proto.InternalMessageInfo

type BroadcastSignalResponse struct {
	// the unique ID of the signal that was broadcasted.
	Key int64 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *BroadcastSignalResponse) Reset()         { *m = BroadcastSignalResponse{} }
func (m *BroadcastSignalResponse) String() string { return proto.CompactTextString(m) }
func (*BroadcastSignalResponse) ProtoMessage()    {}
func (*BroadcastSignalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1e086e530c1ac089, []int{49}
}
func (m *BroadcastSignalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BroadcastSignalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BroadcastSignalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BroadcastSignalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BroadcastSignalResponse.Merge(m, src)
}
func (m *BroadcastSignalResponse) XXX_Size() int {
	return m.XSize()
}
func (m *BroadcastSignalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BroadcastSignalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BroadcastSignalResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("gateway_protocol.Partition_PartitionBrokerRole", Partition_PartitionBrokerRole_name, Partition_PartitionBrokerRole_value)
	proto.RegisterEnum("gateway_protocol.Partition_PartitionBrokerHealth", Partition_PartitionBrokerHealth_name, Partition_PartitionBrokerHealth_value)
	proto.RegisterType((*ActivateJobsRequest)(nil), "gateway_protocol.ActivateJobsRequest")
	proto.RegisterType((*ActivateJobsResponse)(nil), "gateway_protocol.ActivateJobsResponse")
	proto.RegisterType((*ActivatedJob)(nil), "gateway_protocol.ActivatedJob")
	proto.RegisterType((*CancelProcessInstanceRequest)(nil), "gateway_protocol.CancelProcessInstanceRequest")
	proto.RegisterType((*CancelProcessInstanceResponse)(nil), "gateway_protocol.CancelProcessInstanceResponse")
	proto.RegisterType((*CompleteJobRequest)(nil), "gateway_protocol.CompleteJobRequest")
	proto.RegisterType((*CompleteJobResponse)(nil), "gateway_protocol.CompleteJobResponse")
	proto.RegisterType((*CreateProcessInstanceRequest)(nil), "gateway_protocol.CreateProcessInstanceRequest")
	proto.RegisterType((*ProcessInstanceCreationStartInstruction)(nil), "gateway_protocol.ProcessInstanceCreationStartInstruction")
	proto.RegisterType((*CreateProcessInstanceResponse)(nil), "gateway_protocol.CreateProcessInstanceResponse")
	proto.RegisterType((*CreateProcessInstanceWithResultRequest)(nil), "gateway_protocol.CreateProcessInstanceWithResultRequest")
	proto.RegisterType((*CreateProcessInstanceWithResultResponse)(nil), "gateway_protocol.CreateProcessInstanceWithResultResponse")
	proto.RegisterType((*EvaluateDecisionRequest)(nil), "gateway_protocol.EvaluateDecisionRequest")
	proto.RegisterType((*EvaluateDecisionResponse)(nil), "gateway_protocol.EvaluateDecisionResponse")
	proto.RegisterType((*EvaluatedDecision)(nil), "gateway_protocol.EvaluatedDecision")
	proto.RegisterType((*EvaluatedDecisionInput)(nil), "gateway_protocol.EvaluatedDecisionInput")
	proto.RegisterType((*EvaluatedDecisionOutput)(nil), "gateway_protocol.EvaluatedDecisionOutput")
	proto.RegisterType((*MatchedDecisionRule)(nil), "gateway_protocol.MatchedDecisionRule")
	proto.RegisterType((*DeployProcessRequest)(nil), "gateway_protocol.DeployProcessRequest")
	proto.RegisterType((*ProcessRequestObject)(nil), "gateway_protocol.ProcessRequestObject")
	proto.RegisterType((*DeployProcessResponse)(nil), "gateway_protocol.DeployProcessResponse")
	proto.RegisterType((*DeployResourceRequest)(nil), "gateway_protocol.DeployResourceRequest")
	proto.RegisterType((*Resource)(nil), "gateway_protocol.Resource")
	proto.RegisterType((*DeployResourceResponse)(nil), "gateway_protocol.DeployResourceResponse")
	proto.RegisterType((*Deployment)(nil), "gateway_protocol.Deployment")
	proto.RegisterType((*ProcessMetadata)(nil), "gateway_protocol.ProcessMetadata")
	proto.RegisterType((*DecisionMetadata)(nil), "gateway_protocol.DecisionMetadata")
	proto.RegisterType((*DecisionRequirementsMetadata)(nil), "gateway_protocol.DecisionRequirementsMetadata")
	proto.RegisterType((*FailJobRequest)(nil), "gateway_protocol.FailJobRequest")
	proto.RegisterType((*FailJobResponse)(nil), "gateway_protocol.FailJobResponse")
	proto.RegisterType((*ThrowErrorRequest)(nil), "gateway_protocol.ThrowErrorRequest")
	proto.RegisterType((*ThrowErrorResponse)(nil), "gateway_protocol.ThrowErrorResponse")
	proto.RegisterType((*PublishMessageRequest)(nil), "gateway_protocol.PublishMessageRequest")
	proto.RegisterType((*PublishMessageResponse)(nil), "gateway_protocol.PublishMessageResponse")
	proto.RegisterType((*ResolveIncidentRequest)(nil), "gateway_protocol.ResolveIncidentRequest")
	proto.RegisterType((*ResolveIncidentResponse)(nil), "gateway_protocol.ResolveIncidentResponse")
	proto.RegisterType((*TopologyRequest)(nil), "gateway_protocol.TopologyRequest")
	proto.RegisterType((*TopologyResponse)(nil), "gateway_protocol.TopologyResponse")
	proto.RegisterType((*BrokerInfo)(nil), "gateway_protocol.BrokerInfo")
	proto.RegisterType((*Partition)(nil), "gateway_protocol.Partition")
	proto.RegisterType((*UpdateJobRetriesRequest)(nil), "gateway_protocol.UpdateJobRetriesRequest")
	proto.RegisterType((*UpdateJobRetriesResponse)(nil), "gateway_protocol.UpdateJobRetriesResponse")
	proto.RegisterType((*SetVariablesRequest)(nil), "gateway_protocol.SetVariablesRequest")
	proto.RegisterType((*SetVariablesResponse)(nil), "gateway_protocol.SetVariablesResponse")
	proto.RegisterType((*ModifyProcessInstanceRequest)(nil), "gateway_protocol.ModifyProcessInstanceRequest")
	proto.RegisterType((*ModifyProcessInstanceRequest_ActivateInstruction)(nil), "gateway_protocol.ModifyProcessInstanceRequest.ActivateInstruction")
	proto.RegisterType((*ModifyProcessInstanceRequest_VariableInstruction)(nil), "gateway_protocol.ModifyProcessInstanceRequest.VariableInstruction")
	proto.RegisterType((*ModifyProcessInstanceRequest_TerminateInstruction)(nil), "gateway_protocol.ModifyProcessInstanceRequest.TerminateInstruction")
	proto.RegisterType((*ModifyProcessInstanceResponse)(nil), "gateway_protocol.ModifyProcessInstanceResponse")
	proto.RegisterType((*DeleteResourceRequest)(nil), "gateway_protocol.DeleteResourceRequest")
	proto.RegisterType((*DeleteResourceResponse)(nil), "gateway_protocol.DeleteResourceResponse")
	proto.RegisterType((*BroadcastSignalRequest)(nil), "gateway_protocol.BroadcastSignalRequest")
	proto.RegisterType((*BroadcastSignalResponse)(nil), "gateway_protocol.BroadcastSignalResponse")
}

func init() { proto.RegisterFile("zeebe/pkg/pb/gateway.proto", fileDescriptor_1e086e530c1ac089) }

var fileDescriptor_1e086e530c1ac089 = []byte{
	// 2503 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x1a, 0x4d, 0x73, 0xdc, 0x48,
	0x75, 0x34, 0xe3, 0xcf, 0x67, 0xc7, 0x1e, 0xb7, 0x3f, 0xa2, 0x9d, 0x75, 0x1c, 0x47, 0x24, 0x8e,
	0x37, 0x6c, 0x39, 0x60, 0xaa, 0xb6, 0x92, 0x40, 0x96, 0x8d, 0xed, 0xc9, 0xda, 0xd9, 0xc4, 0x09,
	0xb2, 0xe3, 0xad, 0xa5, 0xa8, 0x5a, 0x34, 0x52, 0xdb, 0x56, 0xac, 0x51, 0x0f, 0x92, 0xc6, 0xd9,
	0xc9, 0x0f, 0xa0, 0xa8, 0xa2, 0x8a, 0xe2, 0x44, 0xc1, 0x15, 0x2e, 0x70, 0xe2, 0x07, 0x70, 0x83,
	0x2a, 0x6a, 0x8f, 0x7b, 0x83, 0xe2, 0x04, 0xc9, 0x71, 0xe1, 0x37, 0x40, 0x75, 0xab, 0x5b, 0xd3,
	0x92, 0x5a, 0x9a, 0x49, 0xa0, 0x28, 0xb8, 0xa9, 0x5f, 0xbf, 0x7e, 0x5f, 0xfd, 0xfa, 0xbd, 0xd7,
	0xaf, 0x05, 0x8d, 0x17, 0x18, 0xb7, 0xf0, 0xcd, 0xce, 0xd9, 0xc9, 0xcd, 0x4e, 0xeb, 0xe6, 0x89,
	0x15, 0xe1, 0xe7, 0x56, 0x6f, 0xa3, 0x13, 0x90, 0x88, 0xa0, 0x3a, 0x1f, 0x7e, 0xca, 0x86, 0x36,
	0xf1, 0x8c, 0x3f, 0x69, 0x30, 0x7f, 0xcf, 0x8e, 0xdc, 0x73, 0x2b, 0xc2, 0x0f, 0x48, 0x2b, 0x34,
	0xf1, 0x0f, 0xba, 0x38, 0x8c, 0x10, 0x82, 0x91, 0xa8, 0xd7, 0xc1, 0xba, 0xb6, 0xaa, 0xad, 0x4f,
	0x9a, 0xec, 0x1b, 0x2d, 0xc1, 0xd8, 0x73, 0x12, 0x9c, 0xe1, 0x40, 0xaf, 0x32, 0x28, 0x1f, 0x21,
	0x1d, 0xc6, 0x23, 0xb7, 0x8d, 0x49, 0x37, 0xd2, 0x6b, 0xab, 0xda, 0x7a, 0xcd, 0x14, 0x43, 0xf4,
	0x2e, 0xcc, 0xb5, 0xad, 0xcf, 0x28, 0xdd, 0x43, 0x22, 0xb8, 0xe8, 0x23, 0xab, 0xda, 0xfa, 0xa8,
	0x99, 0x9f, 0x40, 0x57, 0xe1, 0xc2, 0x31, 0x8e, 0xec, 0xd3, 0x23, 0x2b, 0x70, 0xad, 0x96, 0x87,
	0xf5, 0xd1, 0xd5, 0xda, 0xfa, 0xa4, 0x99, 0x06, 0xa2, 0x35, 0x98, 0x09, 0x62, 0x21, 0x0f, 0x39,
	0xd3, 0x31, 0xc6, 0x34, 0x03, 0x35, 0x1e, 0xc0, 0x42, 0x5a, 0xb1, 0xb0, 0x43, 0xfc, 0x10, 0xa3,
	0x4d, 0x18, 0x79, 0x46, 0x5a, 0xa1, 0xae, 0xad, 0xd6, 0xd6, 0xa7, 0x36, 0x57, 0x36, 0xb2, 0x26,
	0xd9, 0x10, 0xab, 0x9c, 0x07, 0xa4, 0x65, 0x32, 0x5c, 0xe3, 0x2f, 0x35, 0x98, 0x96, 0xc1, 0xa8,
	0x0e, 0xb5, 0x33, 0xdc, 0x63, 0xd6, 0xa9, 0x99, 0xf4, 0x33, 0x31, 0x58, 0x55, 0x32, 0xd8, 0x06,
	0xa0, 0x4e, 0x40, 0x6c, 0x1c, 0x86, 0x7b, 0x7e, 0x18, 0x59, 0xbe, 0x8d, 0x3f, 0xc2, 0x3d, 0x6e,
	0x23, 0xc5, 0x0c, 0x35, 0x40, 0xab, 0xd3, 0xf6, 0x9f, 0xf0, 0x19, 0x87, 0x99, 0x6a, 0xd2, 0x4c,
	0x03, 0xd1, 0x1d, 0xd0, 0xf9, 0xda, 0x1d, 0x7c, 0xec, 0xfa, 0x6e, 0xe4, 0x12, 0xff, 0x08, 0x07,
	0xa1, 0x4b, 0x7c, 0x7d, 0x94, 0xd9, 0xb6, 0x70, 0x1e, 0x6d, 0xc2, 0x42, 0x6e, 0x8e, 0xca, 0x14,
	0x9b, 0x50, 0x39, 0x87, 0x96, 0x61, 0x12, 0x7b, 0xb8, 0x8d, 0xfd, 0x68, 0xcf, 0xd1, 0xc7, 0x99,
	0x44, 0x7d, 0x00, 0xd5, 0x51, 0x0c, 0x24, 0x1d, 0x27, 0x62, 0x1d, 0xf3, 0x33, 0x54, 0x47, 0xbb,
	0x1b, 0x46, 0xa4, 0xbd, 0x8b, 0x2d, 0x07, 0x07, 0xa1, 0x3e, 0x19, 0xeb, 0x98, 0x02, 0x4a, 0xae,
	0x06, 0x59, 0x57, 0x0b, 0x70, 0x14, 0xb8, 0x38, 0xd4, 0xa7, 0x98, 0xaa, 0x62, 0x88, 0x1a, 0x30,
	0xe1, 0x60, 0xcb, 0xf1, 0x5c, 0x1f, 0xeb, 0xd3, 0x8c, 0x7b, 0x32, 0xa6, 0x1a, 0x9c, 0x73, 0xf7,
	0x09, 0xf5, 0x0b, 0xb1, 0x06, 0x09, 0xc0, 0xd8, 0x87, 0xe5, 0x6d, 0x2a, 0x9d, 0xf7, 0x24, 0xbd,
	0x23, 0xe2, 0x28, 0xa8, 0x77, 0x51, 0x2b, 0xda, 0x45, 0xe3, 0x32, 0x5c, 0x2a, 0xa0, 0x17, 0x7b,
	0xa0, 0xf1, 0x00, 0xd0, 0x36, 0x69, 0x77, 0x3c, 0xcc, 0x3c, 0x53, 0xb0, 0x59, 0x82, 0xb1, 0x67,
	0xa4, 0xd5, 0x27, 0xcd, 0x47, 0x69, 0xe1, 0xab, 0x59, 0xe1, 0x17, 0x61, 0x3e, 0x45, 0x8b, 0xb3,
	0xf8, 0x45, 0x15, 0x96, 0xb7, 0x03, 0x6c, 0x45, 0xb8, 0x40, 0xa9, 0x22, 0x47, 0xd0, 0x4a, 0x1c,
	0x21, 0xe7, 0x9e, 0x55, 0x95, 0x7b, 0xea, 0x30, 0x7e, 0xce, 0xbd, 0xb1, 0x16, 0x6f, 0x11, 0x1f,
	0xa6, 0x35, 0x19, 0xc9, 0x68, 0x82, 0x4e, 0x60, 0x2e, 0x8c, 0xac, 0x80, 0x39, 0x4b, 0xd0, 0xb5,
	0x29, 0xd3, 0x90, 0x45, 0x80, 0xa9, 0xcd, 0xdb, 0xf9, 0x43, 0x9a, 0x51, 0x8b, 0xe9, 0xea, 0x12,
	0xff, 0x20, 0x43, 0xc1, 0xcc, 0xd3, 0x34, 0x3e, 0x84, 0xeb, 0x43, 0xae, 0x4e, 0xbb, 0xbe, 0x96,
	0x71, 0x7d, 0xe3, 0x0f, 0x1a, 0x5c, 0x2a, 0x30, 0x72, 0x12, 0x6b, 0xfe, 0xfb, 0x56, 0x56, 0xbb,
	0xeb, 0x48, 0xa1, 0xbb, 0xfe, 0x5e, 0x83, 0x35, 0xa5, 0x16, 0x1f, 0xbb, 0xd1, 0xa9, 0x89, 0xc3,
	0xae, 0x17, 0x09, 0xa7, 0xd9, 0xa5, 0xa7, 0x8f, 0x7d, 0x32, 0x0d, 0xa6, 0x36, 0x37, 0xf2, 0x1b,
	0x53, 0xe6, 0x75, 0xa6, 0x58, 0xae, 0x08, 0xe2, 0x55, 0x55, 0x10, 0xa7, 0x78, 0xa9, 0xe8, 0x1f,
	0xea, 0x35, 0x96, 0x13, 0x32, 0x50, 0xe3, 0x4b, 0x0d, 0xae, 0x0f, 0x54, 0xe2, 0xff, 0x67, 0x53,
	0xd2, 0x47, 0x65, 0x34, 0x7b, 0xe8, 0x7b, 0x70, 0xb1, 0x79, 0x6e, 0x79, 0x5d, 0x2b, 0xc2, 0x3b,
	0xd8, 0x76, 0x29, 0x07, 0xb1, 0x45, 0xab, 0x30, 0xe5, 0x70, 0x50, 0x5f, 0x27, 0x19, 0x84, 0x56,
	0x00, 0xc4, 0x30, 0xd1, 0x43, 0x82, 0xa4, 0x59, 0xd7, 0xb2, 0xac, 0xff, 0x51, 0x03, 0x3d, 0xcf,
	0x9b, 0x5b, 0xf6, 0xdf, 0x67, 0x6e, 0xc0, 0xb4, 0x18, 0xed, 0x5b, 0x6d, 0xcc, 0xf9, 0xa7, 0x60,
	0x68, 0x1d, 0x66, 0xc5, 0x58, 0xa4, 0xbd, 0xb8, 0xa4, 0xc8, 0x82, 0xd1, 0x7b, 0xb0, 0xe4, 0x48,
	0xf6, 0x71, 0x03, 0x76, 0x72, 0xe9, 0xf6, 0xc5, 0x26, 0x2d, 0x98, 0x45, 0xb7, 0xe0, 0xa2, 0x6a,
	0xa6, 0x9f, 0x28, 0x8b, 0xa6, 0xa9, 0xbf, 0x8a, 0xa9, 0xc7, 0xdd, 0xa8, 0xd3, 0x8d, 0x78, 0xc2,
	0xcc, 0x40, 0xd1, 0x01, 0x20, 0xcc, 0xad, 0xe8, 0x08, 0x33, 0x86, 0xfa, 0x04, 0x8b, 0x76, 0x5f,
	0xc9, 0x1f, 0xaa, 0x66, 0x16, 0xd7, 0x54, 0x2c, 0x47, 0x37, 0xa0, 0x7e, 0x6c, 0xb9, 0x5e, 0x1f,
	0xb4, 0xe7, 0xf0, 0xec, 0x9a, 0x83, 0xb3, 0x83, 0x65, 0xb9, 0x5e, 0x37, 0xc0, 0x8f, 0x70, 0x18,
	0x5a, 0x27, 0x98, 0x27, 0xda, 0x0c, 0xd4, 0xf8, 0x49, 0x0d, 0xe6, 0x72, 0xdc, 0xff, 0xe7, 0x36,
	0x5a, 0xa2, 0x76, 0x48, 0x8b, 0xb0, 0xd1, 0x34, 0x35, 0x0a, 0x53, 0x6c, 0xcd, 0x98, 0x72, 0x6b,
	0xf6, 0x60, 0xba, 0x6d, 0x45, 0xf6, 0x29, 0x76, 0xcc, 0x2e, 0x3d, 0x02, 0xe3, 0x6c, 0x53, 0xae,
	0xe5, 0x37, 0xe5, 0x51, 0x8c, 0x95, 0x6c, 0x49, 0xd7, 0xc3, 0x66, 0x6a, 0x29, 0x32, 0x61, 0x36,
	0xd9, 0xa6, 0x3d, 0xbf, 0xd3, 0x8d, 0xc4, 0x16, 0xaf, 0x0f, 0xb1, 0xc5, 0x6c, 0x81, 0x99, 0x25,
	0x60, 0x74, 0x60, 0x49, 0x8d, 0x4a, 0xa3, 0x8f, 0x4b, 0x3f, 0x92, 0x54, 0x25, 0x86, 0xf4, 0x48,
	0xb3, 0x4f, 0x66, 0x69, 0x5e, 0x42, 0x24, 0x00, 0xba, 0x55, 0x6c, 0x70, 0x64, 0x79, 0x5d, 0xb1,
	0x11, 0x12, 0xc4, 0x78, 0xde, 0x8f, 0x36, 0x09, 0x47, 0x6e, 0xab, 0x06, 0x4c, 0x10, 0xf6, 0x95,
	0xf0, 0x4c, 0xc6, 0x94, 0x6c, 0xfc, 0x2d, 0x71, 0x95, 0x20, 0xd4, 0x87, 0xe2, 0x91, 0xcc, 0x57,
	0x06, 0x19, 0xbf, 0xd4, 0x60, 0x5e, 0x61, 0x64, 0x5a, 0x29, 0x05, 0x5d, 0x0f, 0x27, 0x3c, 0xf9,
	0x88, 0xaa, 0xc9, 0xbe, 0x7c, 0x07, 0x7f, 0xc6, 0x18, 0x8e, 0x9a, 0x7d, 0x00, 0x7a, 0x0a, 0xf5,
	0xc4, 0x96, 0xb1, 0xf8, 0x71, 0x32, 0x99, 0xda, 0x7c, 0x67, 0x88, 0xdd, 0x88, 0x57, 0x98, 0x39,
	0x12, 0xc6, 0xf7, 0x61, 0x61, 0x07, 0x77, 0x3c, 0xd2, 0xe3, 0x69, 0x40, 0x04, 0xe2, 0x1d, 0x98,
	0xe4, 0x71, 0x1d, 0x8b, 0xbb, 0xc6, 0x5a, 0x61, 0x19, 0xc3, 0x17, 0x3d, 0x6e, 0x3d, 0xc3, 0x76,
	0x64, 0xf6, 0x17, 0xde, 0xa9, 0xea, 0x9a, 0xb1, 0x0f, 0x0b, 0x2a, 0x34, 0x7a, 0xe3, 0xf0, 0xa9,
	0x69, 0xf9, 0x15, 0xcd, 0xe7, 0x7b, 0xe9, 0x24, 0x89, 0x8b, 0xd9, 0x60, 0xda, 0x94, 0x20, 0x8c,
	0x9e, 0x0f, 0x8b, 0x19, 0x89, 0x79, 0xf8, 0xce, 0x5f, 0x6a, 0xbe, 0x2d, 0x2b, 0x51, 0x65, 0x4a,
	0x5c, 0x29, 0x54, 0xe2, 0x11, 0x8e, 0x2c, 0xc7, 0x8a, 0xac, 0xac, 0xfc, 0xdf, 0x11, 0xfc, 0x4c,
	0x1c, 0x92, 0x6e, 0xd0, 0xaf, 0x41, 0x6f, 0xc1, 0x64, 0xc0, 0x41, 0xc2, 0x44, 0x8d, 0x3c, 0xf5,
	0x64, 0x55, 0x1f, 0xd9, 0xb8, 0x05, 0x13, 0x02, 0xac, 0x34, 0x83, 0x0e, 0xe3, 0x36, 0xf1, 0x23,
	0xec, 0x47, 0xdc, 0x06, 0x62, 0x68, 0x3c, 0x83, 0xa5, 0xac, 0x30, 0x85, 0xda, 0xbf, 0x4f, 0xa3,
	0x1c, 0xc5, 0x65, 0xe1, 0x9d, 0xeb, 0xbf, 0x9c, 0x97, 0x70, 0x27, 0x41, 0x32, 0xe5, 0x05, 0xc6,
	0x3f, 0x35, 0x80, 0xfe, 0x1c, 0xba, 0x0b, 0xe3, 0xdc, 0x30, 0xbc, 0x7a, 0x1a, 0x6c, 0xca, 0xdd,
	0x8a, 0x29, 0xd6, 0xa0, 0x0f, 0xe8, 0x05, 0x27, 0x76, 0x46, 0xa6, 0xd4, 0xd4, 0xa6, 0xa1, 0x12,
	0x25, 0xc6, 0x90, 0x08, 0x24, 0xab, 0x90, 0x03, 0x0b, 0xaa, 0xbc, 0xc5, 0x8e, 0x9e, 0xb2, 0x96,
	0xdb, 0x51, 0x60, 0x4b, 0x94, 0x95, 0xd4, 0xb6, 0x00, 0x26, 0x04, 0x8e, 0xf1, 0x1b, 0x0d, 0x66,
	0x33, 0x2a, 0xe5, 0x4b, 0x29, 0x6d, 0x40, 0x29, 0x55, 0x4d, 0x97, 0x52, 0x45, 0xe5, 0x5b, 0xad,
	0xa4, 0x7c, 0x33, 0x60, 0x5a, 0x38, 0x0f, 0x8b, 0x46, 0xf1, 0xe5, 0x23, 0x05, 0x33, 0x7e, 0x56,
	0x85, 0x7a, 0xd6, 0x7c, 0x54, 0x58, 0xa7, 0xed, 0x4b, 0xf9, 0x94, 0x0b, 0x9b, 0x02, 0xb2, 0x44,
	0xd5, 0x07, 0x48, 0xf1, 0x2e, 0x0b, 0x2e, 0xa9, 0x10, 0x33, 0x29, 0x75, 0x24, 0x9f, 0x52, 0xbf,
	0x05, 0x6f, 0x49, 0xe4, 0x94, 0x05, 0x4d, 0x31, 0xc2, 0x9b, 0xd7, 0x34, 0xd4, 0x30, 0xcb, 0x65,
	0x9e, 0x50, 0x2e, 0x98, 0x36, 0x48, 0xb0, 0x0f, 0xe0, 0xed, 0x82, 0x49, 0xc9, 0x90, 0x65, 0x28,
	0x25, 0x46, 0x2d, 0x51, 0x7a, 0xa4, 0xbc, 0x90, 0xcb, 0x7a, 0xcc, 0xa8, 0xc2, 0x63, 0x7e, 0xad,
	0xc1, 0xcc, 0x7d, 0xcb, 0xf5, 0x86, 0xb8, 0xc4, 0x4b, 0x7d, 0x8b, 0x6a, 0xba, 0x6f, 0x61, 0xc0,
	0x34, 0x0e, 0x02, 0x12, 0x88, 0x32, 0x8c, 0x17, 0x42, 0x32, 0x2c, 0x16, 0x26, 0x0a, 0x7a, 0x5b,
	0x96, 0x7d, 0xf6, 0xf8, 0xf8, 0x98, 0xcb, 0x9e, 0x82, 0x0d, 0xb8, 0x31, 0xcc, 0xc1, 0x6c, 0x22,
	0x29, 0x6f, 0x11, 0xfc, 0x58, 0x83, 0xb9, 0xc3, 0xd3, 0x80, 0x3c, 0x6f, 0x52, 0x56, 0x43, 0x74,
	0x21, 0x98, 0x48, 0xdb, 0xc4, 0x49, 0x4a, 0x88, 0x04, 0x30, 0x94, 0x12, 0xa5, 0xb7, 0x7f, 0x63,
	0x01, 0x90, 0x2c, 0x0c, 0x97, 0xf1, 0xb7, 0x1a, 0x2c, 0x3e, 0xe9, 0xb6, 0x3c, 0x37, 0x3c, 0xe5,
	0x64, 0xa4, 0xfe, 0x64, 0x2e, 0xea, 0xaf, 0xc1, 0x8c, 0x4d, 0x82, 0x00, 0x7b, 0x96, 0x88, 0x09,
	0xb1, 0xa0, 0x19, 0x28, 0x4d, 0x92, 0x91, 0xdb, 0xc6, 0x87, 0xe4, 0xa1, 0x7b, 0x8e, 0x79, 0xdc,
	0x90, 0x20, 0x54, 0xd2, 0x76, 0xcc, 0x2d, 0x69, 0xc1, 0xf5, 0x01, 0x03, 0x0c, 0x7d, 0x03, 0x96,
	0xb2, 0x02, 0x17, 0xe5, 0x17, 0xe3, 0x0e, 0x2c, 0xd1, 0x2c, 0xe4, 0x9d, 0xe3, 0x3d, 0xdf, 0x76,
	0x1d, 0x9a, 0x3f, 0xfa, 0xb7, 0x38, 0x97, 0x83, 0xa4, 0xfa, 0x5a, 0x02, 0x19, 0x6f, 0xc1, 0xc5,
	0xdc, 0x5a, 0x6e, 0xb4, 0x39, 0x98, 0x3d, 0x24, 0x1d, 0xe2, 0x91, 0x93, 0x1e, 0xa7, 0x67, 0xfc,
	0x5d, 0x83, 0x7a, 0x1f, 0xc6, 0x05, 0x7a, 0x0f, 0xc6, 0x5b, 0x01, 0x39, 0xc3, 0x81, 0x48, 0xbe,
	0x8a, 0xd4, 0xb6, 0xc5, 0x10, 0xf6, 0xfc, 0x63, 0x62, 0x0a, 0x64, 0x2a, 0x9c, 0xed, 0x75, 0xc3,
	0x08, 0x07, 0x07, 0xee, 0x0b, 0xcc, 0xfd, 0x59, 0x06, 0xd1, 0x78, 0xd8, 0xb1, 0x82, 0x88, 0x85,
	0xdf, 0x70, 0x9b, 0x74, 0xfd, 0x88, 0x1f, 0xcc, 0x2c, 0x18, 0xbd, 0x0b, 0x73, 0x01, 0xee, 0x78,
	0xae, 0xcd, 0x36, 0xe7, 0xbe, 0x65, 0x47, 0x24, 0x10, 0x0d, 0xe2, 0xdc, 0x04, 0xdd, 0x60, 0x2e,
	0xa1, 0xdc, 0xef, 0x9c, 0x34, 0x33, 0x50, 0xe3, 0x57, 0x1a, 0x40, 0x5f, 0x72, 0xea, 0xd3, 0x3e,
	0x71, 0x44, 0xbd, 0x38, 0x6a, 0xf2, 0x11, 0xf5, 0xa1, 0x53, 0x12, 0x46, 0xa2, 0x65, 0x4b, 0xbf,
	0x29, 0xac, 0x43, 0x02, 0x21, 0x2f, 0xfb, 0x46, 0xdf, 0x04, 0xe8, 0xcb, 0xad, 0x8f, 0x30, 0x5b,
	0xbd, 0xad, 0xc8, 0xdd, 0x02, 0xc7, 0x94, 0xd0, 0xe5, 0xe0, 0x14, 0x0b, 0x2b, 0x86, 0xc6, 0xef,
	0xaa, 0x30, 0x99, 0xac, 0xa1, 0x56, 0x4d, 0x56, 0x25, 0x92, 0xca, 0x20, 0xb4, 0x0d, 0x23, 0x01,
	0xf1, 0x62, 0x83, 0xcf, 0x6c, 0xde, 0x2c, 0x11, 0xa0, 0xff, 0x15, 0x5b, 0xc1, 0x24, 0x1e, 0x36,
	0xd9, 0x62, 0xb4, 0x07, 0x63, 0xa7, 0xd8, 0xf2, 0xa2, 0x53, 0xa6, 0xe1, 0xcc, 0xe6, 0xd7, 0x5f,
	0x83, 0xcc, 0x2e, 0x5b, 0x68, 0x72, 0x02, 0xc6, 0x5d, 0x98, 0x57, 0xf0, 0x41, 0x00, 0x63, 0x0f,
	0x9b, 0xf7, 0x76, 0x9a, 0x66, 0xbd, 0x82, 0xa6, 0x61, 0xe2, 0xfe, 0xe3, 0x87, 0x0f, 0x1f, 0x7f,
	0xdc, 0x34, 0xeb, 0x1a, 0x1d, 0xed, 0xed, 0xdf, 0xdb, 0x3e, 0xdc, 0x3b, 0x6a, 0xd6, 0xab, 0xc6,
	0x5d, 0x58, 0x54, 0xd2, 0x47, 0x53, 0x30, 0xbe, 0xdb, 0xbc, 0xf7, 0xf0, 0x70, 0xf7, 0x93, 0x7a,
	0x05, 0x5d, 0x80, 0xc9, 0xa7, 0xfb, 0x62, 0xa8, 0xa1, 0x09, 0x18, 0xd9, 0x69, 0xde, 0xdb, 0xa9,
	0x57, 0x8d, 0x8f, 0xe0, 0xe2, 0xd3, 0x8e, 0x63, 0xf1, 0xb6, 0x27, 0x8b, 0xa5, 0x6f, 0x1c, 0x84,
	0x8d, 0x06, 0xe8, 0x79, 0x62, 0xfc, 0x38, 0xf5, 0x60, 0xfe, 0x00, 0x47, 0x49, 0xab, 0x49, 0xea,
	0x0a, 0x2b, 0xfa, 0xde, 0x5a, 0x61, 0xdf, 0xbb, 0xb4, 0x8d, 0x8b, 0x16, 0x60, 0xd4, 0x23, 0xb6,
	0xe5, 0xb1, 0x5d, 0x99, 0x30, 0xe3, 0x81, 0xb1, 0x0e, 0x0b, 0x69, 0xd6, 0x85, 0xa1, 0xe4, 0x8f,
	0xa3, 0xb0, 0xfc, 0x88, 0x38, 0xee, 0x71, 0xef, 0x3f, 0xd3, 0xc4, 0x46, 0xe7, 0xb0, 0x60, 0xf1,
	0x07, 0x8f, 0x54, 0x43, 0x36, 0x2e, 0x82, 0xb7, 0x14, 0xb7, 0xe1, 0x12, 0xee, 0xc9, 0x93, 0x8a,
	0xdc, 0x99, 0x55, 0xd2, 0x47, 0x3d, 0x58, 0x8c, 0x70, 0xd0, 0x76, 0xfd, 0x2c, 0xe3, 0xf8, 0xaa,
	0xb6, 0xfd, 0x9a, 0x8c, 0x0f, 0x15, 0xb4, 0x4c, 0x35, 0x87, 0xc6, 0x97, 0xd2, 0x53, 0xd8, 0xd0,
	0x4d, 0x60, 0xf4, 0x3e, 0x34, 0x28, 0xc3, 0x30, 0x22, 0x41, 0x33, 0xef, 0x0f, 0x71, 0x57, 0xb3,
	0x04, 0x83, 0x1a, 0x5a, 0xb8, 0x81, 0x42, 0xdf, 0xd7, 0x35, 0xf4, 0x51, 0x9e, 0x94, 0xa9, 0xa4,
	0xdf, 0x78, 0x04, 0xf3, 0x0a, 0xe4, 0xb4, 0x9b, 0x6a, 0x59, 0x37, 0xd5, 0x61, 0x3c, 0xb4, 0x49,
	0x07, 0x27, 0x2d, 0x1d, 0x31, 0x6c, 0xdc, 0x87, 0x05, 0x95, 0xad, 0x5f, 0xf7, 0x98, 0x18, 0x97,
	0xe1, 0x52, 0x81, 0x82, 0xfc, 0x38, 0xde, 0xa6, 0xb7, 0x49, 0x0f, 0x47, 0x38, 0x7b, 0x9b, 0x5c,
	0x85, 0x29, 0x51, 0x9d, 0x49, 0x39, 0x53, 0x02, 0x19, 0x3a, 0xbd, 0xfb, 0xa5, 0x97, 0x72, 0xa2,
	0x47, 0xb0, 0xb4, 0x15, 0x10, 0xcb, 0xb1, 0xad, 0x30, 0x3a, 0x70, 0x4f, 0x7c, 0xcb, 0x13, 0x54,
	0x57, 0x00, 0x42, 0x06, 0xd8, 0xef, 0x57, 0x1b, 0x12, 0x64, 0xc0, 0xeb, 0xcc, 0x57, 0xe1, 0x62,
	0x8e, 0x6e, 0xd1, 0x19, 0xde, 0xfc, 0xe1, 0x2c, 0x8c, 0x7f, 0x18, 0xef, 0x36, 0xb2, 0xfa, 0xef,
	0x8d, 0x0f, 0x48, 0x2b, 0x44, 0xd7, 0x8a, 0x9f, 0x29, 0xa5, 0x57, 0xdb, 0xc6, 0xda, 0x20, 0x34,
	0xae, 0x6f, 0xe5, 0x6b, 0x1a, 0x7a, 0x01, 0x8b, 0xca, 0x67, 0x2a, 0xa4, 0x6a, 0xea, 0x97, 0xbc,
	0x8f, 0x35, 0x6e, 0x0e, 0x8d, 0x2f, 0xb8, 0xa3, 0xef, 0xc1, 0x94, 0xf4, 0x6a, 0x85, 0xae, 0x2a,
	0x28, 0xe4, 0x1e, 0xc8, 0x1a, 0xd7, 0x06, 0x60, 0x25, 0xd4, 0xa9, 0x66, 0xaa, 0xb7, 0x00, 0xf4,
	0x9a, 0xcf, 0x15, 0x4a, 0xcd, 0xca, 0xde, 0x7b, 0x8c, 0x0a, 0xfa, 0xb9, 0x06, 0x97, 0x07, 0x3c,
	0x44, 0xa0, 0x5b, 0x43, 0x92, 0xcd, 0x3d, 0xc0, 0x34, 0x6e, 0xbf, 0xc1, 0xca, 0x44, 0xb4, 0x33,
	0xa8, 0x67, 0x3b, 0xf7, 0xa8, 0xa4, 0xf5, 0x95, 0x79, 0x59, 0x68, 0xdc, 0x18, 0x06, 0x35, 0x61,
	0x86, 0xe1, 0x42, 0xaa, 0xc9, 0x84, 0xd6, 0x8a, 0xfa, 0x26, 0xe9, 0xde, 0x56, 0xe3, 0xfa, 0x40,
	0x3c, 0xce, 0xa3, 0xf6, 0xa3, 0xaa, 0x86, 0x30, 0xcc, 0xa4, 0xdb, 0x39, 0xa8, 0x70, 0x7d, 0x26,
	0x5e, 0x34, 0xd6, 0x07, 0x23, 0x26, 0xda, 0x3c, 0x81, 0x71, 0x7e, 0x7d, 0x42, 0xab, 0xf9, 0x65,
	0xe9, 0x3b, 0x60, 0xe3, 0x4a, 0x09, 0x46, 0x42, 0xf1, 0x13, 0x80, 0xfe, 0x7d, 0x07, 0x29, 0x5a,
	0xfe, 0xb9, 0xab, 0x59, 0xe3, 0x6a, 0x39, 0x92, 0x64, 0xfa, 0x99, 0xf4, 0x15, 0x44, 0x65, 0x13,
	0xe5, 0xad, 0x4a, 0x65, 0x13, 0xf5, 0x6d, 0xc6, 0xa8, 0xa0, 0x53, 0x98, 0xcd, 0xdc, 0x40, 0xd0,
	0xba, 0xba, 0x7b, 0x97, 0xbf, 0xe0, 0x34, 0xde, 0x19, 0x02, 0x33, 0xe1, 0xf4, 0x29, 0x4c, 0xcb,
	0x65, 0x90, 0x2a, 0x18, 0x2a, 0x2a, 0x34, 0x55, 0x30, 0x54, 0x55, 0x53, 0x46, 0x05, 0x1d, 0xc0,
	0x84, 0xb8, 0x1d, 0x21, 0xc5, 0xee, 0x65, 0x6e, 0x53, 0x0d, 0xa3, 0x0c, 0x45, 0x3e, 0x6e, 0xd9,
	0x9a, 0x52, 0x75, 0xdc, 0x0a, 0x8a, 0x58, 0xd5, 0x71, 0x2b, 0x2c, 0x51, 0x59, 0xc8, 0x53, 0xa6,
	0x4d, 0x55, 0xc8, 0x2b, 0x2b, 0x20, 0x54, 0x21, 0xaf, 0x3c, 0x1f, 0x57, 0xe2, 0x33, 0x28, 0xa7,
	0x55, 0xf5, 0x19, 0x54, 0xe4, 0x6c, 0xf5, 0x19, 0x54, 0x66, 0x68, 0xe6, 0x6f, 0x99, 0x5c, 0xaa,
	0xf2, 0x37, 0x75, 0x1a, 0x57, 0xf9, 0x5b, 0x41, 0x62, 0x36, 0x2a, 0x5b, 0xcd, 0xcf, 0xff, 0xb6,
	0x52, 0xf9, 0xfc, 0xe5, 0x8a, 0xf6, 0xc5, 0xcb, 0x15, 0xed, 0xaf, 0x2f, 0x57, 0xb4, 0x9f, 0xbe,
	0x5a, 0xa9, 0x7c, 0xf1, 0x6a, 0xa5, 0xf2, 0xe7, 0x57, 0x2b, 0x15, 0xb8, 0xe2, 0x92, 0x0d, 0xdb,
	0x6a, 0x77, 0x7d, 0xc7, 0xda, 0x60, 0xbf, 0x5a, 0x6d, 0xa4, 0xfe, 0xb1, 0xb2, 0x89, 0xf7, 0xa4,
	0xf2, 0xdd, 0x6a, 0xa7, 0xd5, 0x1a, 0x63, 0xe3, 0x6f, 0xfc, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x56,
	0x29, 0x3d, 0xd2, 0x91, 0x25, 0x00, 0x00,
}

func (m *ActivateJobsRequest) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Worker)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovGateway(uint64(m.Timeout))
	}
	if m.MaxJobsToActivate != 0 {
		n += 1 + sovGateway(uint64(m.MaxJobsToActivate))
	}
	if len(m.FetchVariable) > 0 {
		for _, s := range m.FetchVariable {
			l = len(s)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if m.RequestTimeout != 0 {
		n += 1 + sovGateway(uint64(m.RequestTimeout))
	}
	return n
}

func (m *ActivateJobsResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Jobs) > 0 {
		for _, e := range m.Jobs {
			l = e.XSize()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *ActivatedJob) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovGateway(uint64(m.Key))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.ProcessInstanceKey != 0 {
		n += 1 + sovGateway(uint64(m.ProcessInstanceKey))
	}
	l = len(m.BpmnProcessId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.ProcessDefinitionVersion != 0 {
		n += 1 + sovGateway(uint64(m.ProcessDefinitionVersion))
	}
	if m.ProcessDefinitionKey != 0 {
		n += 1 + sovGateway(uint64(m.ProcessDefinitionKey))
	}
	l = len(m.ElementId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.ElementInstanceKey != 0 {
		n += 1 + sovGateway(uint64(m.ElementInstanceKey))
	}
	l = len(m.CustomHeaders)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Worker)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Retries != 0 {
		n += 1 + sovGateway(uint64(m.Retries))
	}
	if m.Deadline != 0 {
		n += 1 + sovGateway(uint64(m.Deadline))
	}
	l = len(m.Variables)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *CancelProcessInstanceRequest) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProcessInstanceKey != 0 {
		n += 1 + sovGateway(uint64(m.ProcessInstanceKey))
	}
	return n
}

func (m *CancelProcessInstanceResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CompleteJobRequest) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobKey != 0 {
		n += 1 + sovGateway(uint64(m.JobKey))
	}
	l = len(m.Variables)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *CompleteJobResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *CreateProcessInstanceRequest) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProcessDefinitionKey != 0 {
		n += 1 + sovGateway(uint64(m.ProcessDefinitionKey))
	}
	l = len(m.BpmnProcessId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovGateway(uint64(m.Version))
	}
	l = len(m.Variables)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.StartInstructions) > 0 {
		for _, e := range m.StartInstructions {
			l = e.XSize()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *ProcessInstanceCreationStartInstruction) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ElementId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *CreateProcessInstanceResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProcessDefinitionKey != 0 {
		n += 1 + sovGateway(uint64(m.ProcessDefinitionKey))
	}
	l = len(m.BpmnProcessId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovGateway(uint64(m.Version))
	}
	if m.ProcessInstanceKey != 0 {
		n += 1 + sovGateway(uint64(m.ProcessInstanceKey))
	}
	return n
}

func (m *CreateProcessInstanceWithResultRequest) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.XSize()
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.RequestTimeout != 0 {
		n += 1 + sovGateway(uint64(m.RequestTimeout))
	}
	if len(m.FetchVariables) > 0 {
		for _, s := range m.FetchVariables {
			l = len(s)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *CreateProcessInstanceWithResultResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProcessDefinitionKey != 0 {
		n += 1 + sovGateway(uint64(m.ProcessDefinitionKey))
	}
	l = len(m.BpmnProcessId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovGateway(uint64(m.Version))
	}
	if m.ProcessInstanceKey != 0 {
		n += 1 + sovGateway(uint64(m.ProcessInstanceKey))
	}
	l = len(m.Variables)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *EvaluateDecisionRequest) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DecisionKey != 0 {
		n += 1 + sovGateway(uint64(m.DecisionKey))
	}
	l = len(m.DecisionId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Variables)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *EvaluateDecisionResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DecisionKey != 0 {
		n += 1 + sovGateway(uint64(m.DecisionKey))
	}
	l = len(m.DecisionId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.DecisionName)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.DecisionVersion != 0 {
		n += 1 + sovGateway(uint64(m.DecisionVersion))
	}
	l = len(m.DecisionRequirementsId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.DecisionRequirementsKey != 0 {
		n += 1 + sovGateway(uint64(m.DecisionRequirementsKey))
	}
	l = len(m.DecisionOutput)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.EvaluatedDecisions) > 0 {
		for _, e := range m.EvaluatedDecisions {
			l = e.XSize()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	l = len(m.FailedDecisionId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.FailureMessage)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *EvaluatedDecision) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DecisionKey != 0 {
		n += 1 + sovGateway(uint64(m.DecisionKey))
	}
	l = len(m.DecisionId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.DecisionName)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.DecisionVersion != 0 {
		n += 1 + sovGateway(uint64(m.DecisionVersion))
	}
	l = len(m.DecisionType)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.DecisionOutput)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if len(m.MatchedRules) > 0 {
		for _, e := range m.MatchedRules {
			l = e.XSize()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.EvaluatedInputs) > 0 {
		for _, e := range m.EvaluatedInputs {
			l = e.XSize()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *EvaluatedDecisionInput) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InputId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.InputName)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.InputValue)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *EvaluatedDecisionOutput) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OutputId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.OutputName)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.OutputValue)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *MatchedDecisionRule) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RuleId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.RuleIndex != 0 {
		n += 1 + sovGateway(uint64(m.RuleIndex))
	}
	if len(m.EvaluatedOutputs) > 0 {
		for _, e := range m.EvaluatedOutputs {
			l = e.XSize()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *DeployProcessRequest) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Processes) > 0 {
		for _, e := range m.Processes {
			l = e.XSize()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *ProcessRequestObject) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Definition)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *DeployProcessResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovGateway(uint64(m.Key))
	}
	if len(m.Processes) > 0 {
		for _, e := range m.Processes {
			l = e.XSize()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *DeployResourceRequest) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.XSize()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *Resource) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *DeployResourceResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovGateway(uint64(m.Key))
	}
	if len(m.Deployments) > 0 {
		for _, e := range m.Deployments {
			l = e.XSize()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *Deployment) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		n += m.Metadata.XSize()
	}
	return n
}

func (m *Deployment_Process) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Process != nil {
		l = m.Process.XSize()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}
func (m *Deployment_Decision) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Decision != nil {
		l = m.Decision.XSize()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}
func (m *Deployment_DecisionRequirements) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DecisionRequirements != nil {
		l = m.DecisionRequirements.XSize()
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}
func (m *ProcessMetadata) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BpmnProcessId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovGateway(uint64(m.Version))
	}
	if m.ProcessDefinitionKey != 0 {
		n += 1 + sovGateway(uint64(m.ProcessDefinitionKey))
	}
	l = len(m.ResourceName)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *DecisionMetadata) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DmnDecisionId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.DmnDecisionName)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovGateway(uint64(m.Version))
	}
	if m.DecisionKey != 0 {
		n += 1 + sovGateway(uint64(m.DecisionKey))
	}
	l = len(m.DmnDecisionRequirementsId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.DecisionRequirementsKey != 0 {
		n += 1 + sovGateway(uint64(m.DecisionRequirementsKey))
	}
	return n
}

func (m *DecisionRequirementsMetadata) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DmnDecisionRequirementsId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.DmnDecisionRequirementsName)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovGateway(uint64(m.Version))
	}
	if m.DecisionRequirementsKey != 0 {
		n += 1 + sovGateway(uint64(m.DecisionRequirementsKey))
	}
	l = len(m.ResourceName)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *FailJobRequest) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobKey != 0 {
		n += 1 + sovGateway(uint64(m.JobKey))
	}
	if m.Retries != 0 {
		n += 1 + sovGateway(uint64(m.Retries))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.RetryBackOff != 0 {
		n += 1 + sovGateway(uint64(m.RetryBackOff))
	}
	l = len(m.Variables)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *FailJobResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ThrowErrorRequest) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobKey != 0 {
		n += 1 + sovGateway(uint64(m.JobKey))
	}
	l = len(m.ErrorCode)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Variables)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *ThrowErrorResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *PublishMessageRequest) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.CorrelationKey)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.TimeToLive != 0 {
		n += 1 + sovGateway(uint64(m.TimeToLive))
	}
	l = len(m.MessageId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Variables)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *PublishMessageResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovGateway(uint64(m.Key))
	}
	return n
}

func (m *ResolveIncidentRequest) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IncidentKey != 0 {
		n += 1 + sovGateway(uint64(m.IncidentKey))
	}
	return n
}

func (m *ResolveIncidentResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TopologyRequest) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TopologyResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Brokers) > 0 {
		for _, e := range m.Brokers {
			l = e.XSize()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if m.ClusterSize != 0 {
		n += 1 + sovGateway(uint64(m.ClusterSize))
	}
	if m.PartitionsCount != 0 {
		n += 1 + sovGateway(uint64(m.PartitionsCount))
	}
	if m.ReplicationFactor != 0 {
		n += 1 + sovGateway(uint64(m.ReplicationFactor))
	}
	l = len(m.GatewayVersion)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *BrokerInfo) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovGateway(uint64(m.NodeId))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovGateway(uint64(m.Port))
	}
	if len(m.Partitions) > 0 {
		for _, e := range m.Partitions {
			l = e.XSize()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *Partition) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PartitionId != 0 {
		n += 1 + sovGateway(uint64(m.PartitionId))
	}
	if m.Role != 0 {
		n += 1 + sovGateway(uint64(m.Role))
	}
	if m.Health != 0 {
		n += 1 + sovGateway(uint64(m.Health))
	}
	return n
}

func (m *UpdateJobRetriesRequest) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobKey != 0 {
		n += 1 + sovGateway(uint64(m.JobKey))
	}
	if m.Retries != 0 {
		n += 1 + sovGateway(uint64(m.Retries))
	}
	return n
}

func (m *UpdateJobRetriesResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SetVariablesRequest) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ElementInstanceKey != 0 {
		n += 1 + sovGateway(uint64(m.ElementInstanceKey))
	}
	l = len(m.Variables)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Local {
		n += 2
	}
	return n
}

func (m *SetVariablesResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovGateway(uint64(m.Key))
	}
	return n
}

func (m *ModifyProcessInstanceRequest) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProcessInstanceKey != 0 {
		n += 1 + sovGateway(uint64(m.ProcessInstanceKey))
	}
	if len(m.ActivateInstructions) > 0 {
		for _, e := range m.ActivateInstructions {
			l = e.XSize()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	if len(m.TerminateInstructions) > 0 {
		for _, e := range m.TerminateInstructions {
			l = e.XSize()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *ModifyProcessInstanceRequest_ActivateInstruction) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ElementId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.AncestorElementInstanceKey != 0 {
		n += 1 + sovGateway(uint64(m.AncestorElementInstanceKey))
	}
	if len(m.VariableInstructions) > 0 {
		for _, e := range m.VariableInstructions {
			l = e.XSize()
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	return n
}

func (m *ModifyProcessInstanceRequest_VariableInstruction) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Variables)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.ScopeId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *ModifyProcessInstanceRequest_TerminateInstruction) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ElementInstanceKey != 0 {
		n += 1 + sovGateway(uint64(m.ElementInstanceKey))
	}
	return n
}

func (m *ModifyProcessInstanceResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DeleteResourceRequest) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResourceKey != 0 {
		n += 1 + sovGateway(uint64(m.ResourceKey))
	}
	return n
}

func (m *DeleteResourceResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BroadcastSignalRequest) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SignalName)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Variables)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *BroadcastSignalResponse) XSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovGateway(uint64(m.Key))
	}
	return n
}

func sovGateway(x uint64) (n int) {
	return (bits.Len64(x|1) + 6) / 7
}
func sozGateway(x uint64) (n int) {
	return sovGateway(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ActivateJobsRequest) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateJobsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActivateJobsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequestTimeout != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.RequestTimeout))
		i--
		dAtA[i] = 0x30
	}
	if len(m.FetchVariable) > 0 {
		for iNdEx := len(m.FetchVariable) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FetchVariable[iNdEx])
			copy(dAtA[i:], m.FetchVariable[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.FetchVariable[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxJobsToActivate != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.MaxJobsToActivate))
		i--
		dAtA[i] = 0x20
	}
	if m.Timeout != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Worker) > 0 {
		i -= len(m.Worker)
		copy(dAtA[i:], m.Worker)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Worker)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActivateJobsResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateJobsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActivateJobsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Jobs) > 0 {
		for iNdEx := len(m.Jobs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Jobs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActivatedJob) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivatedJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActivatedJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Variables) > 0 {
		i -= len(m.Variables)
		copy(dAtA[i:], m.Variables)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Variables)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Deadline != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Deadline))
		i--
		dAtA[i] = 0x60
	}
	if m.Retries != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Retries))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Worker) > 0 {
		i -= len(m.Worker)
		copy(dAtA[i:], m.Worker)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Worker)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CustomHeaders) > 0 {
		i -= len(m.CustomHeaders)
		copy(dAtA[i:], m.CustomHeaders)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.CustomHeaders)))
		i--
		dAtA[i] = 0x4a
	}
	if m.ElementInstanceKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ElementInstanceKey))
		i--
		dAtA[i] = 0x40
	}
	if len(m.ElementId) > 0 {
		i -= len(m.ElementId)
		copy(dAtA[i:], m.ElementId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ElementId)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ProcessDefinitionKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ProcessDefinitionKey))
		i--
		dAtA[i] = 0x30
	}
	if m.ProcessDefinitionVersion != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ProcessDefinitionVersion))
		i--
		dAtA[i] = 0x28
	}
	if len(m.BpmnProcessId) > 0 {
		i -= len(m.BpmnProcessId)
		copy(dAtA[i:], m.BpmnProcessId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.BpmnProcessId)))
		i--
		dAtA[i] = 0x22
	}
	if m.ProcessInstanceKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ProcessInstanceKey))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if m.Key != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CancelProcessInstanceRequest) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelProcessInstanceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelProcessInstanceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProcessInstanceKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ProcessInstanceKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CancelProcessInstanceResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelProcessInstanceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelProcessInstanceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CompleteJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompleteJobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompleteJobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Variables) > 0 {
		i -= len(m.Variables)
		copy(dAtA[i:], m.Variables)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Variables)))
		i--
		dAtA[i] = 0x12
	}
	if m.JobKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.JobKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CompleteJobResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompleteJobResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompleteJobResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *CreateProcessInstanceRequest) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateProcessInstanceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateProcessInstanceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StartInstructions) > 0 {
		for iNdEx := len(m.StartInstructions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StartInstructions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Variables) > 0 {
		i -= len(m.Variables)
		copy(dAtA[i:], m.Variables)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Variables)))
		i--
		dAtA[i] = 0x22
	}
	if m.Version != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BpmnProcessId) > 0 {
		i -= len(m.BpmnProcessId)
		copy(dAtA[i:], m.BpmnProcessId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.BpmnProcessId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProcessDefinitionKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ProcessDefinitionKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProcessInstanceCreationStartInstruction) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessInstanceCreationStartInstruction) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessInstanceCreationStartInstruction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ElementId) > 0 {
		i -= len(m.ElementId)
		copy(dAtA[i:], m.ElementId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ElementId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateProcessInstanceResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateProcessInstanceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateProcessInstanceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProcessInstanceKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ProcessInstanceKey))
		i--
		dAtA[i] = 0x20
	}
	if m.Version != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BpmnProcessId) > 0 {
		i -= len(m.BpmnProcessId)
		copy(dAtA[i:], m.BpmnProcessId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.BpmnProcessId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProcessDefinitionKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ProcessDefinitionKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateProcessInstanceWithResultRequest) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateProcessInstanceWithResultRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateProcessInstanceWithResultRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FetchVariables) > 0 {
		for iNdEx := len(m.FetchVariables) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FetchVariables[iNdEx])
			copy(dAtA[i:], m.FetchVariables[iNdEx])
			i = encodeVarintGateway(dAtA, i, uint64(len(m.FetchVariables[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.RequestTimeout != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.RequestTimeout))
		i--
		dAtA[i] = 0x10
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateProcessInstanceWithResultResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateProcessInstanceWithResultResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateProcessInstanceWithResultResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Variables) > 0 {
		i -= len(m.Variables)
		copy(dAtA[i:], m.Variables)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Variables)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ProcessInstanceKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ProcessInstanceKey))
		i--
		dAtA[i] = 0x20
	}
	if m.Version != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if len(m.BpmnProcessId) > 0 {
		i -= len(m.BpmnProcessId)
		copy(dAtA[i:], m.BpmnProcessId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.BpmnProcessId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProcessDefinitionKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ProcessDefinitionKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvaluateDecisionRequest) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvaluateDecisionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvaluateDecisionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Variables) > 0 {
		i -= len(m.Variables)
		copy(dAtA[i:], m.Variables)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Variables)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DecisionId) > 0 {
		i -= len(m.DecisionId)
		copy(dAtA[i:], m.DecisionId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DecisionId)))
		i--
		dAtA[i] = 0x12
	}
	if m.DecisionKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.DecisionKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvaluateDecisionResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvaluateDecisionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvaluateDecisionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FailureMessage) > 0 {
		i -= len(m.FailureMessage)
		copy(dAtA[i:], m.FailureMessage)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.FailureMessage)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.FailedDecisionId) > 0 {
		i -= len(m.FailedDecisionId)
		copy(dAtA[i:], m.FailedDecisionId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.FailedDecisionId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.EvaluatedDecisions) > 0 {
		for iNdEx := len(m.EvaluatedDecisions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EvaluatedDecisions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.DecisionOutput) > 0 {
		i -= len(m.DecisionOutput)
		copy(dAtA[i:], m.DecisionOutput)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DecisionOutput)))
		i--
		dAtA[i] = 0x3a
	}
	if m.DecisionRequirementsKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.DecisionRequirementsKey))
		i--
		dAtA[i] = 0x30
	}
	if len(m.DecisionRequirementsId) > 0 {
		i -= len(m.DecisionRequirementsId)
		copy(dAtA[i:], m.DecisionRequirementsId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DecisionRequirementsId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DecisionVersion != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.DecisionVersion))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DecisionName) > 0 {
		i -= len(m.DecisionName)
		copy(dAtA[i:], m.DecisionName)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DecisionName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DecisionId) > 0 {
		i -= len(m.DecisionId)
		copy(dAtA[i:], m.DecisionId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DecisionId)))
		i--
		dAtA[i] = 0x12
	}
	if m.DecisionKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.DecisionKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvaluatedDecision) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvaluatedDecision) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvaluatedDecision) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EvaluatedInputs) > 0 {
		for iNdEx := len(m.EvaluatedInputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EvaluatedInputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.MatchedRules) > 0 {
		for iNdEx := len(m.MatchedRules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MatchedRules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.DecisionOutput) > 0 {
		i -= len(m.DecisionOutput)
		copy(dAtA[i:], m.DecisionOutput)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DecisionOutput)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DecisionType) > 0 {
		i -= len(m.DecisionType)
		copy(dAtA[i:], m.DecisionType)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DecisionType)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DecisionVersion != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.DecisionVersion))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DecisionName) > 0 {
		i -= len(m.DecisionName)
		copy(dAtA[i:], m.DecisionName)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DecisionName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DecisionId) > 0 {
		i -= len(m.DecisionId)
		copy(dAtA[i:], m.DecisionId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DecisionId)))
		i--
		dAtA[i] = 0x12
	}
	if m.DecisionKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.DecisionKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvaluatedDecisionInput) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvaluatedDecisionInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvaluatedDecisionInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InputValue) > 0 {
		i -= len(m.InputValue)
		copy(dAtA[i:], m.InputValue)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.InputValue)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InputName) > 0 {
		i -= len(m.InputName)
		copy(dAtA[i:], m.InputName)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.InputName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.InputId) > 0 {
		i -= len(m.InputId)
		copy(dAtA[i:], m.InputId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.InputId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvaluatedDecisionOutput) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvaluatedDecisionOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvaluatedDecisionOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OutputValue) > 0 {
		i -= len(m.OutputValue)
		copy(dAtA[i:], m.OutputValue)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.OutputValue)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OutputName) > 0 {
		i -= len(m.OutputName)
		copy(dAtA[i:], m.OutputName)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.OutputName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OutputId) > 0 {
		i -= len(m.OutputId)
		copy(dAtA[i:], m.OutputId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.OutputId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MatchedDecisionRule) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchedDecisionRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MatchedDecisionRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EvaluatedOutputs) > 0 {
		for iNdEx := len(m.EvaluatedOutputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EvaluatedOutputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.RuleIndex != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.RuleIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RuleId) > 0 {
		i -= len(m.RuleId)
		copy(dAtA[i:], m.RuleId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.RuleId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeployProcessRequest) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeployProcessRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeployProcessRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Processes) > 0 {
		for iNdEx := len(m.Processes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Processes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProcessRequestObject) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessRequestObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessRequestObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Definition) > 0 {
		i -= len(m.Definition)
		copy(dAtA[i:], m.Definition)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Definition)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeployProcessResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeployProcessResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeployProcessResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Processes) > 0 {
		for iNdEx := len(m.Processes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Processes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Key != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeployResourceRequest) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeployResourceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeployResourceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for iNdEx := len(m.Resources) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Resources[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Resource) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Resource) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Resource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeployResourceResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeployResourceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeployResourceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Deployments) > 0 {
		for iNdEx := len(m.Deployments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Deployments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Key != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Deployment) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployment) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deployment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		{
			size := m.Metadata.XSize()
			i -= size
			if _, err := m.Metadata.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Deployment_Process) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deployment_Process) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Process != nil {
		{
			size, err := m.Process.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Deployment_Decision) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deployment_Decision) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Decision != nil {
		{
			size, err := m.Decision.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Deployment_DecisionRequirements) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deployment_DecisionRequirements) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DecisionRequirements != nil {
		{
			size, err := m.DecisionRequirements.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGateway(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ProcessMetadata) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResourceName) > 0 {
		i -= len(m.ResourceName)
		copy(dAtA[i:], m.ResourceName)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ResourceName)))
		i--
		dAtA[i] = 0x22
	}
	if m.ProcessDefinitionKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ProcessDefinitionKey))
		i--
		dAtA[i] = 0x18
	}
	if m.Version != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BpmnProcessId) > 0 {
		i -= len(m.BpmnProcessId)
		copy(dAtA[i:], m.BpmnProcessId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.BpmnProcessId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DecisionMetadata) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecisionMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecisionMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DecisionRequirementsKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.DecisionRequirementsKey))
		i--
		dAtA[i] = 0x30
	}
	if len(m.DmnDecisionRequirementsId) > 0 {
		i -= len(m.DmnDecisionRequirementsId)
		copy(dAtA[i:], m.DmnDecisionRequirementsId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DmnDecisionRequirementsId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DecisionKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.DecisionKey))
		i--
		dAtA[i] = 0x20
	}
	if m.Version != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DmnDecisionName) > 0 {
		i -= len(m.DmnDecisionName)
		copy(dAtA[i:], m.DmnDecisionName)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DmnDecisionName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DmnDecisionId) > 0 {
		i -= len(m.DmnDecisionId)
		copy(dAtA[i:], m.DmnDecisionId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DmnDecisionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DecisionRequirementsMetadata) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecisionRequirementsMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecisionRequirementsMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResourceName) > 0 {
		i -= len(m.ResourceName)
		copy(dAtA[i:], m.ResourceName)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ResourceName)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DecisionRequirementsKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.DecisionRequirementsKey))
		i--
		dAtA[i] = 0x20
	}
	if m.Version != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DmnDecisionRequirementsName) > 0 {
		i -= len(m.DmnDecisionRequirementsName)
		copy(dAtA[i:], m.DmnDecisionRequirementsName)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DmnDecisionRequirementsName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DmnDecisionRequirementsId) > 0 {
		i -= len(m.DmnDecisionRequirementsId)
		copy(dAtA[i:], m.DmnDecisionRequirementsId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.DmnDecisionRequirementsId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FailJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FailJobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FailJobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Variables) > 0 {
		i -= len(m.Variables)
		copy(dAtA[i:], m.Variables)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Variables)))
		i--
		dAtA[i] = 0x2a
	}
	if m.RetryBackOff != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.RetryBackOff))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Retries != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Retries))
		i--
		dAtA[i] = 0x10
	}
	if m.JobKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.JobKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FailJobResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FailJobResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FailJobResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ThrowErrorRequest) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThrowErrorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThrowErrorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Variables) > 0 {
		i -= len(m.Variables)
		copy(dAtA[i:], m.Variables)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Variables)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ErrorCode) > 0 {
		i -= len(m.ErrorCode)
		copy(dAtA[i:], m.ErrorCode)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ErrorCode)))
		i--
		dAtA[i] = 0x12
	}
	if m.JobKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.JobKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ThrowErrorResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThrowErrorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThrowErrorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *PublishMessageRequest) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishMessageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublishMessageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Variables) > 0 {
		i -= len(m.Variables)
		copy(dAtA[i:], m.Variables)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Variables)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MessageId) > 0 {
		i -= len(m.MessageId)
		copy(dAtA[i:], m.MessageId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.MessageId)))
		i--
		dAtA[i] = 0x22
	}
	if m.TimeToLive != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.TimeToLive))
		i--
		dAtA[i] = 0x18
	}
	if len(m.CorrelationKey) > 0 {
		i -= len(m.CorrelationKey)
		copy(dAtA[i:], m.CorrelationKey)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.CorrelationKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PublishMessageResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishMessageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublishMessageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResolveIncidentRequest) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveIncidentRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolveIncidentRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IncidentKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.IncidentKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResolveIncidentResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResolveIncidentResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResolveIncidentResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TopologyRequest) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopologyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopologyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TopologyResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopologyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopologyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GatewayVersion) > 0 {
		i -= len(m.GatewayVersion)
		copy(dAtA[i:], m.GatewayVersion)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.GatewayVersion)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ReplicationFactor != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ReplicationFactor))
		i--
		dAtA[i] = 0x20
	}
	if m.PartitionsCount != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.PartitionsCount))
		i--
		dAtA[i] = 0x18
	}
	if m.ClusterSize != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ClusterSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Brokers) > 0 {
		for iNdEx := len(m.Brokers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Brokers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BrokerInfo) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BrokerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BrokerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Partitions) > 0 {
		for iNdEx := len(m.Partitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Partitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Port != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0x12
	}
	if m.NodeId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.NodeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Partition) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Partition) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Partition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Health != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Health))
		i--
		dAtA[i] = 0x18
	}
	if m.Role != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x10
	}
	if m.PartitionId != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.PartitionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateJobRetriesRequest) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateJobRetriesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateJobRetriesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Retries != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Retries))
		i--
		dAtA[i] = 0x10
	}
	if m.JobKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.JobKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateJobRetriesResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateJobRetriesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateJobRetriesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SetVariablesRequest) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetVariablesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetVariablesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Local {
		i--
		if m.Local {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Variables) > 0 {
		i -= len(m.Variables)
		copy(dAtA[i:], m.Variables)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Variables)))
		i--
		dAtA[i] = 0x12
	}
	if m.ElementInstanceKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ElementInstanceKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetVariablesResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetVariablesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetVariablesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ModifyProcessInstanceRequest) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyProcessInstanceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModifyProcessInstanceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TerminateInstructions) > 0 {
		for iNdEx := len(m.TerminateInstructions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TerminateInstructions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ActivateInstructions) > 0 {
		for iNdEx := len(m.ActivateInstructions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ActivateInstructions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ProcessInstanceKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ProcessInstanceKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ModifyProcessInstanceRequest_ActivateInstruction) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyProcessInstanceRequest_ActivateInstruction) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModifyProcessInstanceRequest_ActivateInstruction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.VariableInstructions) > 0 {
		for iNdEx := len(m.VariableInstructions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VariableInstructions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGateway(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.AncestorElementInstanceKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.AncestorElementInstanceKey))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ElementId) > 0 {
		i -= len(m.ElementId)
		copy(dAtA[i:], m.ElementId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ElementId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModifyProcessInstanceRequest_VariableInstruction) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyProcessInstanceRequest_VariableInstruction) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModifyProcessInstanceRequest_VariableInstruction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ScopeId) > 0 {
		i -= len(m.ScopeId)
		copy(dAtA[i:], m.ScopeId)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ScopeId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Variables) > 0 {
		i -= len(m.Variables)
		copy(dAtA[i:], m.Variables)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Variables)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModifyProcessInstanceRequest_TerminateInstruction) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyProcessInstanceRequest_TerminateInstruction) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModifyProcessInstanceRequest_TerminateInstruction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ElementInstanceKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ElementInstanceKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ModifyProcessInstanceResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyProcessInstanceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModifyProcessInstanceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DeleteResourceRequest) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteResourceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteResourceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResourceKey != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.ResourceKey))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteResourceResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteResourceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteResourceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *BroadcastSignalRequest) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BroadcastSignalRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BroadcastSignalRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Variables) > 0 {
		i -= len(m.Variables)
		copy(dAtA[i:], m.Variables)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Variables)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SignalName) > 0 {
		i -= len(m.SignalName)
		copy(dAtA[i:], m.SignalName)
		i = encodeVarintGateway(dAtA, i, uint64(len(m.SignalName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BroadcastSignalResponse) Marshal() (dAtA []byte, err error) {
	size := m.XSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BroadcastSignalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.XSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BroadcastSignalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		i = encodeVarintGateway(dAtA, i, uint64(m.Key))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintGateway(dAtA []byte, offset int, v uint64) int {
	offset -= sovGateway(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ActivateJobsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateJobsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateJobsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Worker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Worker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxJobsToActivate", wireType)
			}
			m.MaxJobsToActivate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxJobsToActivate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FetchVariable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FetchVariable = append(m.FetchVariable, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTimeout", wireType)
			}
			m.RequestTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivateJobsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateJobsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateJobsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jobs = append(m.Jobs, &ActivatedJob{})
			if err := m.Jobs[len(m.Jobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivatedJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivatedJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivatedJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessInstanceKey", wireType)
			}
			m.ProcessInstanceKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessInstanceKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BpmnProcessId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BpmnProcessId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessDefinitionVersion", wireType)
			}
			m.ProcessDefinitionVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessDefinitionVersion |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessDefinitionKey", wireType)
			}
			m.ProcessDefinitionKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessDefinitionKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElementId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElementInstanceKey", wireType)
			}
			m.ElementInstanceKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElementInstanceKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomHeaders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomHeaders = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Worker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Worker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retries", wireType)
			}
			m.Retries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retries |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deadline", wireType)
			}
			m.Deadline = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Deadline |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variables = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelProcessInstanceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelProcessInstanceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelProcessInstanceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessInstanceKey", wireType)
			}
			m.ProcessInstanceKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessInstanceKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelProcessInstanceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelProcessInstanceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelProcessInstanceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompleteJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompleteJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompleteJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobKey", wireType)
			}
			m.JobKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variables = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompleteJobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompleteJobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompleteJobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateProcessInstanceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateProcessInstanceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateProcessInstanceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessDefinitionKey", wireType)
			}
			m.ProcessDefinitionKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessDefinitionKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BpmnProcessId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BpmnProcessId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variables = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartInstructions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartInstructions = append(m.StartInstructions, &ProcessInstanceCreationStartInstruction{})
			if err := m.StartInstructions[len(m.StartInstructions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessInstanceCreationStartInstruction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessInstanceCreationStartInstruction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessInstanceCreationStartInstruction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElementId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateProcessInstanceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateProcessInstanceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateProcessInstanceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessDefinitionKey", wireType)
			}
			m.ProcessDefinitionKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessDefinitionKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BpmnProcessId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BpmnProcessId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessInstanceKey", wireType)
			}
			m.ProcessInstanceKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessInstanceKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateProcessInstanceWithResultRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateProcessInstanceWithResultRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateProcessInstanceWithResultRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &CreateProcessInstanceRequest{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestTimeout", wireType)
			}
			m.RequestTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FetchVariables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FetchVariables = append(m.FetchVariables, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateProcessInstanceWithResultResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateProcessInstanceWithResultResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateProcessInstanceWithResultResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessDefinitionKey", wireType)
			}
			m.ProcessDefinitionKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessDefinitionKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BpmnProcessId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BpmnProcessId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessInstanceKey", wireType)
			}
			m.ProcessInstanceKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessInstanceKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variables = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvaluateDecisionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvaluateDecisionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvaluateDecisionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionKey", wireType)
			}
			m.DecisionKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecisionKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecisionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variables = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvaluateDecisionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvaluateDecisionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvaluateDecisionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionKey", wireType)
			}
			m.DecisionKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecisionKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecisionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecisionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionVersion", wireType)
			}
			m.DecisionVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecisionVersion |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionRequirementsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecisionRequirementsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionRequirementsKey", wireType)
			}
			m.DecisionRequirementsKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecisionRequirementsKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionOutput", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecisionOutput = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvaluatedDecisions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvaluatedDecisions = append(m.EvaluatedDecisions, &EvaluatedDecision{})
			if err := m.EvaluatedDecisions[len(m.EvaluatedDecisions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedDecisionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailedDecisionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailureMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvaluatedDecision) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvaluatedDecision: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvaluatedDecision: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionKey", wireType)
			}
			m.DecisionKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecisionKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecisionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecisionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionVersion", wireType)
			}
			m.DecisionVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecisionVersion |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecisionType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionOutput", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecisionOutput = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchedRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchedRules = append(m.MatchedRules, &MatchedDecisionRule{})
			if err := m.MatchedRules[len(m.MatchedRules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvaluatedInputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvaluatedInputs = append(m.EvaluatedInputs, &EvaluatedDecisionInput{})
			if err := m.EvaluatedInputs[len(m.EvaluatedInputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvaluatedDecisionInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvaluatedDecisionInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvaluatedDecisionInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvaluatedDecisionOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvaluatedDecisionOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvaluatedDecisionOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchedDecisionRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchedDecisionRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchedDecisionRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleIndex", wireType)
			}
			m.RuleIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuleIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvaluatedOutputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvaluatedOutputs = append(m.EvaluatedOutputs, &EvaluatedDecisionOutput{})
			if err := m.EvaluatedOutputs[len(m.EvaluatedOutputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeployProcessRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeployProcessRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeployProcessRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Processes = append(m.Processes, &ProcessRequestObject{})
			if err := m.Processes[len(m.Processes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessRequestObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessRequestObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessRequestObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Definition = append(m.Definition[:0], dAtA[iNdEx:postIndex]...)
			if m.Definition == nil {
				m.Definition = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeployProcessResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeployProcessResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeployProcessResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Processes = append(m.Processes, &ProcessMetadata{})
			if err := m.Processes[len(m.Processes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeployResourceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeployResourceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeployResourceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, &Resource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Resource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeployResourceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeployResourceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeployResourceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deployments = append(m.Deployments, &Deployment{})
			if err := m.Deployments[len(m.Deployments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Process", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProcessMetadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Metadata = &Deployment_Process{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decision", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DecisionMetadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Metadata = &Deployment_Decision{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DecisionRequirementsMetadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Metadata = &Deployment_DecisionRequirements{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BpmnProcessId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BpmnProcessId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessDefinitionKey", wireType)
			}
			m.ProcessDefinitionKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessDefinitionKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecisionMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecisionMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecisionMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DmnDecisionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DmnDecisionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DmnDecisionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DmnDecisionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionKey", wireType)
			}
			m.DecisionKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecisionKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DmnDecisionRequirementsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DmnDecisionRequirementsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionRequirementsKey", wireType)
			}
			m.DecisionRequirementsKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecisionRequirementsKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecisionRequirementsMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecisionRequirementsMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecisionRequirementsMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DmnDecisionRequirementsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DmnDecisionRequirementsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DmnDecisionRequirementsName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DmnDecisionRequirementsName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionRequirementsKey", wireType)
			}
			m.DecisionRequirementsKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DecisionRequirementsKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FailJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FailJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FailJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobKey", wireType)
			}
			m.JobKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retries", wireType)
			}
			m.Retries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retries |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryBackOff", wireType)
			}
			m.RetryBackOff = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryBackOff |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variables = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FailJobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FailJobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FailJobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThrowErrorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThrowErrorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThrowErrorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobKey", wireType)
			}
			m.JobKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variables = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThrowErrorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThrowErrorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThrowErrorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishMessageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishMessageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishMessageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorrelationKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CorrelationKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeToLive", wireType)
			}
			m.TimeToLive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeToLive |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variables = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishMessageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishMessageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishMessageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveIncidentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveIncidentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveIncidentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncidentKey", wireType)
			}
			m.IncidentKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IncidentKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResolveIncidentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResolveIncidentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResolveIncidentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopologyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopologyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopologyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopologyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopologyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopologyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Brokers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Brokers = append(m.Brokers, &BrokerInfo{})
			if err := m.Brokers[len(m.Brokers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterSize", wireType)
			}
			m.ClusterSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionsCount", wireType)
			}
			m.PartitionsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionsCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicationFactor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BrokerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BrokerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BrokerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitions = append(m.Partitions, &Partition{})
			if err := m.Partitions[len(m.Partitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Partition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Partition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Partition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionId", wireType)
			}
			m.PartitionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartitionId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= Partition_PartitionBrokerRole(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			m.Health = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Health |= Partition_PartitionBrokerHealth(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateJobRetriesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateJobRetriesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateJobRetriesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobKey", wireType)
			}
			m.JobKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retries", wireType)
			}
			m.Retries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retries |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateJobRetriesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateJobRetriesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateJobRetriesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetVariablesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetVariablesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetVariablesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElementInstanceKey", wireType)
			}
			m.ElementInstanceKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElementInstanceKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variables = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Local = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetVariablesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetVariablesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetVariablesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyProcessInstanceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifyProcessInstanceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifyProcessInstanceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessInstanceKey", wireType)
			}
			m.ProcessInstanceKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessInstanceKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivateInstructions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivateInstructions = append(m.ActivateInstructions, &ModifyProcessInstanceRequest_ActivateInstruction{})
			if err := m.ActivateInstructions[len(m.ActivateInstructions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TerminateInstructions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TerminateInstructions = append(m.TerminateInstructions, &ModifyProcessInstanceRequest_TerminateInstruction{})
			if err := m.TerminateInstructions[len(m.TerminateInstructions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyProcessInstanceRequest_ActivateInstruction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateInstruction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateInstruction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ElementId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AncestorElementInstanceKey", wireType)
			}
			m.AncestorElementInstanceKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AncestorElementInstanceKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VariableInstructions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VariableInstructions = append(m.VariableInstructions, &ModifyProcessInstanceRequest_VariableInstruction{})
			if err := m.VariableInstructions[len(m.VariableInstructions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyProcessInstanceRequest_VariableInstruction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VariableInstruction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VariableInstruction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variables = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyProcessInstanceRequest_TerminateInstruction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TerminateInstruction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TerminateInstruction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElementInstanceKey", wireType)
			}
			m.ElementInstanceKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ElementInstanceKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyProcessInstanceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifyProcessInstanceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifyProcessInstanceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteResourceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteResourceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteResourceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceKey", wireType)
			}
			m.ResourceKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceKey |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteResourceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteResourceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteResourceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BroadcastSignalRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BroadcastSignalRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BroadcastSignalRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignalName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignalName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variables", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGateway
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Variables = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BroadcastSignalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BroadcastSignalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BroadcastSignalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGateway(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGateway
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGateway
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGateway
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGateway        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGateway          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGateway = fmt.Errorf("proto: unexpected end of group")
)

// GatewayClient is the client API for Gateway service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GatewayClient interface {
	//
	//Iterates through all known partitions round-robin and activates up to the requested
	//maximum and streams them back to the client as they are activated.
	//
	//Errors:
	//INVALID_ARGUMENT:
	//- type is blank (empty string, null)
	//- worker is blank (empty string, null)
	//- timeout less than 1
	//- maxJobsToActivate is less than 1
	ActivateJobs(ctx context.Context, in *ActivateJobsRequest, opts ...grpc.CallOption) (Gateway_ActivateJobsClient, error)
	//
	//Cancels a running process instance
	//
	//Errors:
	//NOT_FOUND:
	//- no process instance exists with the given key
	CancelProcessInstance(ctx context.Context, in *CancelProcessInstanceRequest, opts ...grpc.CallOption) (*CancelProcessInstanceResponse, error)
	//
	//Completes a job with the given variables, which allows completing the associated service task.
	//
	//Errors:
	//NOT_FOUND:
	//- no job exists with the given job key. Note that since jobs are removed once completed,
	//it could be that this job did exist at some point.
	//
	//FAILED_PRECONDITION:
	//- the job was marked as failed. In that case, the related incident must be resolved before
	//the job can be activated again and completed.
	CompleteJob(ctx context.Context, in *CompleteJobRequest, opts ...grpc.CallOption) (*CompleteJobResponse, error)
	//
	//Creates and starts an instance of the specified process. The process definition to use to
	//create the instance can be specified either using its unique key (as returned by
	//DeployProcess), or using the BPMN process ID and a version. Pass -1 as the version to use the
	//latest deployed version. Note that only processes with none start events can be started through
	//this command.
	//
	//Errors:
	//NOT_FOUND:
	//- no process with the given key exists (if processDefinitionKey was given)
	//- no process with the given process ID exists (if bpmnProcessId was given but version was -1)
	//- no process with the given process ID and version exists (if both bpmnProcessId and version were given)
	//
	//FAILED_PRECONDITION:
	//- the process definition does not contain a none start event; only processes with none
	//start event can be started manually.
	//
	//INVALID_ARGUMENT:
	//- the given variables argument is not a valid JSON document; it is expected to be a valid
	//JSON document where the root node is an object.
	CreateProcessInstance(ctx context.Context, in *CreateProcessInstanceRequest, opts ...grpc.CallOption) (*CreateProcessInstanceResponse, error)
	//
	//Behaves similarly to `rpc CreateProcessInstance`, except that a successful response is received when the process completes successfully.
	CreateProcessInstanceWithResult(ctx context.Context, in *CreateProcessInstanceWithResultRequest, opts ...grpc.CallOption) (*CreateProcessInstanceWithResultResponse, error)
	//
	//Evaluates a decision. The decision to evaluate can be specified either by
	//using its unique key (as returned by DeployResource), or using the decision
	//ID. When using the decision ID, the latest deployed version of the decision
	//is used.
	//
	//Errors:
	//INVALID_ARGUMENT:
	//- no decision with the given key exists (if decisionKey was given)
	//- no decision with the given decision ID exists (if decisionId was given)
	//- both decision ID and decision KEY were provided, or are missing
	EvaluateDecision(ctx context.Context, in *EvaluateDecisionRequest, opts ...grpc.CallOption) (*EvaluateDecisionResponse, error)
	//
	//Deploys one or more processes to Zeebe. Note that this is an atomic call,
	//i.e. either all processes are deployed, or none of them are.
	//
	//Errors:
	//INVALID_ARGUMENT:
	//- no resources given.
	//- if at least one resource is invalid. A resource is considered invalid if:
	//- the resource data is not deserializable (e.g. detected as BPMN, but it's broken XML)
	//- the process is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
	DeployProcess(ctx context.Context, in *DeployProcessRequest, opts ...grpc.CallOption) (*DeployProcessResponse, error)
	//
	//Deploys one or more resources (e.g. processes or decision models) to Zeebe.
	//Note that this is an atomic call, i.e. either all resources are deployed, or none of them are.
	//
	//Errors:
	//INVALID_ARGUMENT:
	//- no resources given.
	//- if at least one resource is invalid. A resource is considered invalid if:
	//- the content is not deserializable (e.g. detected as BPMN, but it's broken XML)
	//- the content is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
	DeployResource(ctx context.Context, in *DeployResourceRequest, opts ...grpc.CallOption) (*DeployResourceResponse, error)
	//
	//Marks the job as failed; if the retries argument is positive, then the job will be immediately
	//activatable again, and a worker could try again to process it. If it is zero or negative however,
	//an incident will be raised, tagged with the given errorMessage, and the job will not be
	//activatable until the incident is resolved.
	//
	//Errors:
	//NOT_FOUND:
	//- no job was found with the given key
	//
	//FAILED_PRECONDITION:
	//- the job was not activated
	//- the job is already in a failed state, i.e. ran out of retries
	FailJob(ctx context.Context, in *FailJobRequest, opts ...grpc.CallOption) (*FailJobResponse, error)
	//
	//Reports a business error (i.e. non-technical) that occurs while processing a job. The error is handled in the process by an error catch event. If there is no error catch event with the specified errorCode then an incident will be raised instead.
	//
	//Errors:
	//NOT_FOUND:
	//- no job was found with the given key
	//
	//FAILED_PRECONDITION:
	//- the job is not in an activated state
	ThrowError(ctx context.Context, in *ThrowErrorRequest, opts ...grpc.CallOption) (*ThrowErrorResponse, error)
	//
	//Publishes a single message. Messages are published to specific partitions computed from their
	//correlation keys.
	//
	//Errors:
	//ALREADY_EXISTS:
	//- a message with the same ID was previously published (and is still alive)
	PublishMessage(ctx context.Context, in *PublishMessageRequest, opts ...grpc.CallOption) (*PublishMessageResponse, error)
	//
	//Resolves a given incident. This simply marks the incident as resolved; most likely a call to
	//UpdateJobRetries or SetVariables will be necessary to actually resolve the
	//problem, following by this call.
	//
	//Errors:
	//NOT_FOUND:
	//- no incident with the given key exists
	ResolveIncident(ctx context.Context, in *ResolveIncidentRequest, opts ...grpc.CallOption) (*ResolveIncidentResponse, error)
	//
	//Updates all the variables of a particular scope (e.g. process instance, flow element instance)
	//from the given JSON document.
	//
	//Errors:
	//NOT_FOUND:
	//- no element with the given elementInstanceKey exists
	//INVALID_ARGUMENT:
	//- the given variables document is not a valid JSON document; valid documents are expected to
	//be JSON documents where the root node is an object.
	SetVariables(ctx context.Context, in *SetVariablesRequest, opts ...grpc.CallOption) (*SetVariablesResponse, error)
	//
	//Obtains the current topology of the cluster the gateway is part of.
	Topology(ctx context.Context, in *TopologyRequest, opts ...grpc.CallOption) (*TopologyResponse, error)
	//
	//Updates the number of retries a job has left. This is mostly useful for jobs that have run out of
	//retries, should the underlying problem be solved.
	//
	//Errors:
	//NOT_FOUND:
	//- no job exists with the given key
	//
	//INVALID_ARGUMENT:
	//- retries is not greater than 0
	UpdateJobRetries(ctx context.Context, in *UpdateJobRetriesRequest, opts ...grpc.CallOption) (*UpdateJobRetriesResponse, error)
	//
	//Modifies the process instance. This is done by activating and/or terminating specific elements of the instance.
	//
	//Errors:
	//NOT_FOUND:
	//- no process instance exists with the given key
	//
	//FAILED_PRECONDITION:
	//- trying to activate element inside of a multi-instance
	//
	//INVALID_ARGUMENT:
	//- activating or terminating unknown element
	//- ancestor of element for activation doesn't exist
	//- scope of variable is unknown
	ModifyProcessInstance(ctx context.Context, in *ModifyProcessInstanceRequest, opts ...grpc.CallOption) (*ModifyProcessInstanceResponse, error)
	//
	//Deletes a resource from the state. Once a resource has been deleted it cannot
	//be recovered. If the resource needs to be available again, a new deployment
	//of the resource is required.
	//
	//Deleting a process will cancel any running instances of this process
	//definition. New instances of a deleted process are created using
	//the lastest version that hasn't been deleted. Creating a new
	//process instance is impossible when all versions have been
	//deleted.
	//
	//Deleting a decision requirement definitions could cause incidents in process
	//instances referencing these decisions in a business rule task. A decision
	//will be evaluated with the latest version that hasn't been deleted. If all
	//versions of a decision have been deleted the evaluation is rejected.
	//
	//Errors:
	//NOT_FOUND:
	//- No resource exists with the given key
	//
	DeleteResource(ctx context.Context, in *DeleteResourceRequest, opts ...grpc.CallOption) (*DeleteResourceResponse, error)
	//
	//Broadcasts a signal.
	BroadcastSignal(ctx context.Context, in *BroadcastSignalRequest, opts ...grpc.CallOption) (*BroadcastSignalResponse, error)
}

type gatewayClient struct {
	cc *grpc.ClientConn
}

func NewGatewayClient(cc *grpc.ClientConn) GatewayClient {
	return &gatewayClient{cc}
}

func (c *gatewayClient) ActivateJobs(ctx context.Context, in *ActivateJobsRequest, opts ...grpc.CallOption) (Gateway_ActivateJobsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Gateway_serviceDesc.Streams[0], "/gateway_protocol.Gateway/ActivateJobs", opts...)
	if err != nil {
		return nil, err
	}
	x := &gatewayActivateJobsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Gateway_ActivateJobsClient interface {
	Recv() (*ActivateJobsResponse, error)
	grpc.ClientStream
}

type gatewayActivateJobsClient struct {
	grpc.ClientStream
}

func (x *gatewayActivateJobsClient) Recv() (*ActivateJobsResponse, error) {
	m := new(ActivateJobsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gatewayClient) CancelProcessInstance(ctx context.Context, in *CancelProcessInstanceRequest, opts ...grpc.CallOption) (*CancelProcessInstanceResponse, error) {
	out := new(CancelProcessInstanceResponse)
	err := c.cc.Invoke(ctx, "/gateway_protocol.Gateway/CancelProcessInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) CompleteJob(ctx context.Context, in *CompleteJobRequest, opts ...grpc.CallOption) (*CompleteJobResponse, error) {
	out := new(CompleteJobResponse)
	err := c.cc.Invoke(ctx, "/gateway_protocol.Gateway/CompleteJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) CreateProcessInstance(ctx context.Context, in *CreateProcessInstanceRequest, opts ...grpc.CallOption) (*CreateProcessInstanceResponse, error) {
	out := new(CreateProcessInstanceResponse)
	err := c.cc.Invoke(ctx, "/gateway_protocol.Gateway/CreateProcessInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) CreateProcessInstanceWithResult(ctx context.Context, in *CreateProcessInstanceWithResultRequest, opts ...grpc.CallOption) (*CreateProcessInstanceWithResultResponse, error) {
	out := new(CreateProcessInstanceWithResultResponse)
	err := c.cc.Invoke(ctx, "/gateway_protocol.Gateway/CreateProcessInstanceWithResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) EvaluateDecision(ctx context.Context, in *EvaluateDecisionRequest, opts ...grpc.CallOption) (*EvaluateDecisionResponse, error) {
	out := new(EvaluateDecisionResponse)
	err := c.cc.Invoke(ctx, "/gateway_protocol.Gateway/EvaluateDecision", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *gatewayClient) DeployProcess(ctx context.Context, in *DeployProcessRequest, opts ...grpc.CallOption) (*DeployProcessResponse, error) {
	out := new(DeployProcessResponse)
	err := c.cc.Invoke(ctx, "/gateway_protocol.Gateway/DeployProcess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) DeployResource(ctx context.Context, in *DeployResourceRequest, opts ...grpc.CallOption) (*DeployResourceResponse, error) {
	out := new(DeployResourceResponse)
	err := c.cc.Invoke(ctx, "/gateway_protocol.Gateway/DeployResource", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) FailJob(ctx context.Context, in *FailJobRequest, opts ...grpc.CallOption) (*FailJobResponse, error) {
	out := new(FailJobResponse)
	err := c.cc.Invoke(ctx, "/gateway_protocol.Gateway/FailJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) ThrowError(ctx context.Context, in *ThrowErrorRequest, opts ...grpc.CallOption) (*ThrowErrorResponse, error) {
	out := new(ThrowErrorResponse)
	err := c.cc.Invoke(ctx, "/gateway_protocol.Gateway/ThrowError", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) PublishMessage(ctx context.Context, in *PublishMessageRequest, opts ...grpc.CallOption) (*PublishMessageResponse, error) {
	out := new(PublishMessageResponse)
	err := c.cc.Invoke(ctx, "/gateway_protocol.Gateway/PublishMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) ResolveIncident(ctx context.Context, in *ResolveIncidentRequest, opts ...grpc.CallOption) (*ResolveIncidentResponse, error) {
	out := new(ResolveIncidentResponse)
	err := c.cc.Invoke(ctx, "/gateway_protocol.Gateway/ResolveIncident", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) SetVariables(ctx context.Context, in *SetVariablesRequest, opts ...grpc.CallOption) (*SetVariablesResponse, error) {
	out := new(SetVariablesResponse)
	err := c.cc.Invoke(ctx, "/gateway_protocol.Gateway/SetVariables", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) Topology(ctx context.Context, in *TopologyRequest, opts ...grpc.CallOption) (*TopologyResponse, error) {
	out := new(TopologyResponse)
	err := c.cc.Invoke(ctx, "/gateway_protocol.Gateway/Topology", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) UpdateJobRetries(ctx context.Context, in *UpdateJobRetriesRequest, opts ...grpc.CallOption) (*UpdateJobRetriesResponse, error) {
	out := new(UpdateJobRetriesResponse)
	err := c.cc.Invoke(ctx, "/gateway_protocol.Gateway/UpdateJobRetries", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) ModifyProcessInstance(ctx context.Context, in *ModifyProcessInstanceRequest, opts ...grpc.CallOption) (*ModifyProcessInstanceResponse, error) {
	out := new(ModifyProcessInstanceResponse)
	err := c.cc.Invoke(ctx, "/gateway_protocol.Gateway/ModifyProcessInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) DeleteResource(ctx context.Context, in *DeleteResourceRequest, opts ...grpc.CallOption) (*DeleteResourceResponse, error) {
	out := new(DeleteResourceResponse)
	err := c.cc.Invoke(ctx, "/gateway_protocol.Gateway/DeleteResource", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gatewayClient) BroadcastSignal(ctx context.Context, in *BroadcastSignalRequest, opts ...grpc.CallOption) (*BroadcastSignalResponse, error) {
	out := new(BroadcastSignalResponse)
	err := c.cc.Invoke(ctx, "/gateway_protocol.Gateway/BroadcastSignal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GatewayServer is the server API for Gateway service.
type GatewayServer interface {
	//
	//Iterates through all known partitions round-robin and activates up to the requested
	//maximum and streams them back to the client as they are activated.
	//
	//Errors:
	//INVALID_ARGUMENT:
	//- type is blank (empty string, null)
	//- worker is blank (empty string, null)
	//- timeout less than 1
	//- maxJobsToActivate is less than 1
	ActivateJobs(*ActivateJobsRequest, Gateway_ActivateJobsServer) error
	//
	//Cancels a running process instance
	//
	//Errors:
	//NOT_FOUND:
	//- no process instance exists with the given key
	CancelProcessInstance(context.Context, *CancelProcessInstanceRequest) (*CancelProcessInstanceResponse, error)
	//
	//Completes a job with the given variables, which allows completing the associated service task.
	//
	//Errors:
	//NOT_FOUND:
	//- no job exists with the given job key. Note that since jobs are removed once completed,
	//it could be that this job did exist at some point.
	//
	//FAILED_PRECONDITION:
	//- the job was marked as failed. In that case, the related incident must be resolved before
	//the job can be activated again and completed.
	CompleteJob(context.Context, *CompleteJobRequest) (*CompleteJobResponse, error)
	//
	//Creates and starts an instance of the specified process. The process definition to use to
	//create the instance can be specified either using its unique key (as returned by
	//DeployProcess), or using the BPMN process ID and a version. Pass -1 as the version to use the
	//latest deployed version. Note that only processes with none start events can be started through
	//this command.
	//
	//Errors:
	//NOT_FOUND:
	//- no process with the given key exists (if processDefinitionKey was given)
	//- no process with the given process ID exists (if bpmnProcessId was given but version was -1)
	//- no process with the given process ID and version exists (if both bpmnProcessId and version were given)
	//
	//FAILED_PRECONDITION:
	//- the process definition does not contain a none start event; only processes with none
	//start event can be started manually.
	//
	//INVALID_ARGUMENT:
	//- the given variables argument is not a valid JSON document; it is expected to be a valid
	//JSON document where the root node is an object.
	CreateProcessInstance(context.Context, *CreateProcessInstanceRequest) (*CreateProcessInstanceResponse, error)
	//
	//Behaves similarly to `rpc CreateProcessInstance`, except that a successful response is received when the process completes successfully.
	CreateProcessInstanceWithResult(context.Context, *CreateProcessInstanceWithResultRequest) (*CreateProcessInstanceWithResultResponse, error)
	//
	//Evaluates a decision. The decision to evaluate can be specified either by
	//using its unique key (as returned by DeployResource), or using the decision
	//ID. When using the decision ID, the latest deployed version of the decision
	//is used.
	//
	//Errors:
	//INVALID_ARGUMENT:
	//- no decision with the given key exists (if decisionKey was given)
	//- no decision with the given decision ID exists (if decisionId was given)
	//- both decision ID and decision KEY were provided, or are missing
	EvaluateDecision(context.Context, *EvaluateDecisionRequest) (*EvaluateDecisionResponse, error)
	//
	//Deploys one or more processes to Zeebe. Note that this is an atomic call,
	//i.e. either all processes are deployed, or none of them are.
	//
	//Errors:
	//INVALID_ARGUMENT:
	//- no resources given.
	//- if at least one resource is invalid. A resource is considered invalid if:
	//- the resource data is not deserializable (e.g. detected as BPMN, but it's broken XML)
	//- the process is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
	DeployProcess(context.Context, *DeployProcessRequest) (*DeployProcessResponse, error)
	//
	//Deploys one or more resources (e.g. processes or decision models) to Zeebe.
	//Note that this is an atomic call, i.e. either all resources are deployed, or none of them are.
	//
	//Errors:
	//INVALID_ARGUMENT:
	//- no resources given.
	//- if at least one resource is invalid. A resource is considered invalid if:
	//- the content is not deserializable (e.g. detected as BPMN, but it's broken XML)
	//- the content is invalid (e.g. an event-based gateway has an outgoing sequence flow to a task)
	DeployResource(context.Context, *DeployResourceRequest) (*DeployResourceResponse, error)
	//
	//Marks the job as failed; if the retries argument is positive, then the job will be immediately
	//activatable again, and a worker could try again to process it. If it is zero or negative however,
	//an incident will be raised, tagged with the given errorMessage, and the job will not be
	//activatable until the incident is resolved.
	//
	//Errors:
	//NOT_FOUND:
	//- no job was found with the given key
	//
	//FAILED_PRECONDITION:
	//- the job was not activated
	//- the job is already in a failed state, i.e. ran out of retries
	FailJob(context.Context, *FailJobRequest) (*FailJobResponse, error)
	//
	//Reports a business error (i.e. non-technical) that occurs while processing a job. The error is handled in the process by an error catch event. If there is no error catch event with the specified errorCode then an incident will be raised instead.
	//
	//Errors:
	//NOT_FOUND:
	//- no job was found with the given key
	//
	//FAILED_PRECONDITION:
	//- the job is not in an activated state
	ThrowError(context.Context, *ThrowErrorRequest) (*ThrowErrorResponse, error)
	//
	//Publishes a single message. Messages are published to specific partitions computed from their
	//correlation keys.
	//
	//Errors:
	//ALREADY_EXISTS:
	//- a message with the same ID was previously published (and is still alive)
	PublishMessage(context.Context, *PublishMessageRequest) (*PublishMessageResponse, error)
	//
	//Resolves a given incident. This simply marks the incident as resolved; most likely a call to
	//UpdateJobRetries or SetVariables will be necessary to actually resolve the
	//problem, following by this call.
	//
	//Errors:
	//NOT_FOUND:
	//- no incident with the given key exists
	ResolveIncident(context.Context, *ResolveIncidentRequest) (*ResolveIncidentResponse, error)
	//
	//Updates all the variables of a particular scope (e.g. process instance, flow element instance)
	//from the given JSON document.
	//
	//Errors:
	//NOT_FOUND:
	//- no element with the given elementInstanceKey exists
	//INVALID_ARGUMENT:
	//- the given variables document is not a valid JSON document; valid documents are expected to
	//be JSON documents where the root node is an object.
	SetVariables(context.Context, *SetVariablesRequest) (*SetVariablesResponse, error)
	//
	//Obtains the current topology of the cluster the gateway is part of.
	Topology(context.Context, *TopologyRequest) (*TopologyResponse, error)
	//
	//Updates the number of retries a job has left. This is mostly useful for jobs that have run out of
	//retries, should the underlying problem be solved.
	//
	//Errors:
	//NOT_FOUND:
	//- no job exists with the given key
	//
	//INVALID_ARGUMENT:
	//- retries is not greater than 0
	UpdateJobRetries(context.Context, *UpdateJobRetriesRequest) (*UpdateJobRetriesResponse, error)
	//
	//Modifies the process instance. This is done by activating and/or terminating specific elements of the instance.
	//
	//Errors:
	//NOT_FOUND:
	//- no process instance exists with the given key
	//
	//FAILED_PRECONDITION:
	//- trying to activate element inside of a multi-instance
	//
	//INVALID_ARGUMENT:
	//- activating or terminating unknown element
	//- ancestor of element for activation doesn't exist
	//- scope of variable is unknown
	ModifyProcessInstance(context.Context, *ModifyProcessInstanceRequest) (*ModifyProcessInstanceResponse, error)
	//
	//Deletes a resource from the state. Once a resource has been deleted it cannot
	//be recovered. If the resource needs to be available again, a new deployment
	//of the resource is required.
	//
	//Deleting a process will cancel any running instances of this process
	//definition. New instances of a deleted process are created using
	//the lastest version that hasn't been deleted. Creating a new
	//process instance is impossible when all versions have been
	//deleted.
	//
	//Deleting a decision requirement definitions could cause incidents in process
	//instances referencing these decisions in a business rule task. A decision
	//will be evaluated with the latest version that hasn't been deleted. If all
	//versions of a decision have been deleted the evaluation is rejected.
	//
	//Errors:
	//NOT_FOUND:
	//- No resource exists with the given key
	//
	DeleteResource(context.Context, *DeleteResourceRequest) (*DeleteResourceResponse, error)
	//
	//Broadcasts a signal.
	BroadcastSignal(context.Context, *BroadcastSignalRequest) (*BroadcastSignalResponse, error)
}

// UnimplementedGatewayServer can be embedded to have forward compatible implementations.
type UnimplementedGatewayServer struct {
}

func (*UnimplementedGatewayServer) ActivateJobs(req *ActivateJobsRequest, srv Gateway_ActivateJobsServer) error {
	return status.Errorf(codes.Unimplemented, "method ActivateJobs not implemented")
}
func (*UnimplementedGatewayServer) CancelProcessInstance(ctx context.Context, req *CancelProcessInstanceRequest) (*CancelProcessInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelProcessInstance not implemented")
}
func (*UnimplementedGatewayServer) CompleteJob(ctx context.Context, req *CompleteJobRequest) (*CompleteJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompleteJob not implemented")
}
func (*UnimplementedGatewayServer) CreateProcessInstance(ctx context.Context, req *CreateProcessInstanceRequest) (*CreateProcessInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProcessInstance not implemented")
}
func (*UnimplementedGatewayServer) CreateProcessInstanceWithResult(ctx context.Context, req *CreateProcessInstanceWithResultRequest) (*CreateProcessInstanceWithResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProcessInstanceWithResult not implemented")
}
func (*UnimplementedGatewayServer) EvaluateDecision(ctx context.Context, req *EvaluateDecisionRequest) (*EvaluateDecisionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EvaluateDecision not implemented")
}
func (*UnimplementedGatewayServer) DeployProcess(ctx context.Context, req *DeployProcessRequest) (*DeployProcessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeployProcess not implemented")
}
func (*UnimplementedGatewayServer) DeployResource(ctx context.Context, req *DeployResourceRequest) (*DeployResourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeployResource not implemented")
}
func (*UnimplementedGatewayServer) FailJob(ctx context.Context, req *FailJobRequest) (*FailJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FailJob not implemented")
}
func (*UnimplementedGatewayServer) ThrowError(ctx context.Context, req *ThrowErrorRequest) (*ThrowErrorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ThrowError not implemented")
}
func (*UnimplementedGatewayServer) PublishMessage(ctx context.Context, req *PublishMessageRequest) (*PublishMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishMessage not implemented")
}
func (*UnimplementedGatewayServer) ResolveIncident(ctx context.Context, req *ResolveIncidentRequest) (*ResolveIncidentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveIncident not implemented")
}
func (*UnimplementedGatewayServer) SetVariables(ctx context.Context, req *SetVariablesRequest) (*SetVariablesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetVariables not implemented")
}
func (*UnimplementedGatewayServer) Topology(ctx context.Context, req *TopologyRequest) (*TopologyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Topology not implemented")
}
func (*UnimplementedGatewayServer) UpdateJobRetries(ctx context.Context, req *UpdateJobRetriesRequest) (*UpdateJobRetriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateJobRetries not implemented")
}
func (*UnimplementedGatewayServer) ModifyProcessInstance(ctx context.Context, req *ModifyProcessInstanceRequest) (*ModifyProcessInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyProcessInstance not implemented")
}
func (*UnimplementedGatewayServer) DeleteResource(ctx context.Context, req *DeleteResourceRequest) (*DeleteResourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteResource not implemented")
}
func (*UnimplementedGatewayServer) BroadcastSignal(ctx context.Context, req *BroadcastSignalRequest) (*BroadcastSignalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BroadcastSignal not implemented")
}

func RegisterGatewayServer(s *grpc.Server, srv GatewayServer) {
	s.RegisterService(&_Gateway_serviceDesc, srv)
}

func _Gateway_ActivateJobs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ActivateJobsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GatewayServer).ActivateJobs(m, &gatewayActivateJobsServer{stream})
}

type Gateway_ActivateJobsServer interface {
	Send(*ActivateJobsResponse) error
	grpc.ServerStream
}

type gatewayActivateJobsServer struct {
	grpc.ServerStream
}

func (x *gatewayActivateJobsServer) Send(m *ActivateJobsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Gateway_CancelProcessInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelProcessInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).CancelProcessInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gateway_protocol.Gateway/CancelProcessInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).CancelProcessInstance(ctx, req.(*CancelProcessInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_CompleteJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompleteJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).CompleteJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gateway_protocol.Gateway/CompleteJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).CompleteJob(ctx, req.(*CompleteJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_CreateProcessInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProcessInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).CreateProcessInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gateway_protocol.Gateway/CreateProcessInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).CreateProcessInstance(ctx, req.(*CreateProcessInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_CreateProcessInstanceWithResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProcessInstanceWithResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).CreateProcessInstanceWithResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gateway_protocol.Gateway/CreateProcessInstanceWithResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).CreateProcessInstanceWithResult(ctx, req.(*CreateProcessInstanceWithResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_EvaluateDecision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EvaluateDecisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).EvaluateDecision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gateway_protocol.Gateway/EvaluateDecision",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).EvaluateDecision(ctx, req.(*EvaluateDecisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_DeployProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeployProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).DeployProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gateway_protocol.Gateway/DeployProcess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).DeployProcess(ctx, req.(*DeployProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_DeployResource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeployResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).DeployResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gateway_protocol.Gateway/DeployResource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).DeployResource(ctx, req.(*DeployResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_FailJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FailJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).FailJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gateway_protocol.Gateway/FailJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).FailJob(ctx, req.(*FailJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_ThrowError_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ThrowErrorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).ThrowError(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gateway_protocol.Gateway/ThrowError",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).ThrowError(ctx, req.(*ThrowErrorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_PublishMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).PublishMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gateway_protocol.Gateway/PublishMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).PublishMessage(ctx, req.(*PublishMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_ResolveIncident_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveIncidentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).ResolveIncident(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gateway_protocol.Gateway/ResolveIncident",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).ResolveIncident(ctx, req.(*ResolveIncidentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_SetVariables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetVariablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).SetVariables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gateway_protocol.Gateway/SetVariables",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).SetVariables(ctx, req.(*SetVariablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_Topology_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TopologyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).Topology(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gateway_protocol.Gateway/Topology",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).Topology(ctx, req.(*TopologyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_UpdateJobRetries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateJobRetriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).UpdateJobRetries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gateway_protocol.Gateway/UpdateJobRetries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).UpdateJobRetries(ctx, req.(*UpdateJobRetriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_ModifyProcessInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModifyProcessInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).ModifyProcessInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gateway_protocol.Gateway/ModifyProcessInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).ModifyProcessInstance(ctx, req.(*ModifyProcessInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_DeleteResource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).DeleteResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gateway_protocol.Gateway/DeleteResource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).DeleteResource(ctx, req.(*DeleteResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Gateway_BroadcastSignal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BroadcastSignalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GatewayServer).BroadcastSignal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gateway_protocol.Gateway/BroadcastSignal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GatewayServer).BroadcastSignal(ctx, req.(*BroadcastSignalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Gateway_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gateway_protocol.Gateway",
	HandlerType: (*GatewayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CancelProcessInstance",
			Handler:    _Gateway_CancelProcessInstance_Handler,
		},
		{
			MethodName: "CompleteJob",
			Handler:    _Gateway_CompleteJob_Handler,
		},
		{
			MethodName: "CreateProcessInstance",
			Handler:    _Gateway_CreateProcessInstance_Handler,
		},
		{
			MethodName: "CreateProcessInstanceWithResult",
			Handler:    _Gateway_CreateProcessInstanceWithResult_Handler,
		},
		{
			MethodName: "EvaluateDecision",
			Handler:    _Gateway_EvaluateDecision_Handler,
		},
		{
			MethodName: "DeployProcess",
			Handler:    _Gateway_DeployProcess_Handler,
		},
		{
			MethodName: "DeployResource",
			Handler:    _Gateway_DeployResource_Handler,
		},
		{
			MethodName: "FailJob",
			Handler:    _Gateway_FailJob_Handler,
		},
		{
			MethodName: "ThrowError",
			Handler:    _Gateway_ThrowError_Handler,
		},
		{
			MethodName: "PublishMessage",
			Handler:    _Gateway_PublishMessage_Handler,
		},
		{
			MethodName: "ResolveIncident",
			Handler:    _Gateway_ResolveIncident_Handler,
		},
		{
			MethodName: "SetVariables",
			Handler:    _Gateway_SetVariables_Handler,
		},
		{
			MethodName: "Topology",
			Handler:    _Gateway_Topology_Handler,
		},
		{
			MethodName: "UpdateJobRetries",
			Handler:    _Gateway_UpdateJobRetries_Handler,
		},
		{
			MethodName: "ModifyProcessInstance",
			Handler:    _Gateway_ModifyProcessInstance_Handler,
		},
		{
			MethodName: "DeleteResource",
			Handler:    _Gateway_DeleteResource_Handler,
		},
		{
			MethodName: "BroadcastSignal",
			Handler:    _Gateway_BroadcastSignal_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ActivateJobs",
			Handler:       _Gateway_ActivateJobs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "zeebe/pkg/pb/gateway.proto",
}
